<?xml version="1.0" encoding="utf-8"?>
  <rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>maow</title>
    <link href="/feed/" rel="self" />
    <link href="http://hscs506.github.io/" />
    <lastBuildDate>2018-04-26T17:21:43+08:00</lastBuildDate>
    <webMaster>maow.cd@foxmail.com</webMaster>
    
    <item>
      <title>QEMU Develop Manual</title>
      <link href="/2018/04/qemu-develop-manual/"/>
      <pubDate>2018-04-26T00:00:00+08:00</pubDate>
      <author>maow</author>
      <guid>/2018/04/qemu-develop-manual</guid>
      <content:encoded><![CDATA[<p>本文主要分析QEMU的建模API</p>

<h1 id="machine-api">Machine API</h1>

<h2 id="machine-register-api">Machine Register API</h2>

<h3 id="查看默认的machine">查看默认的Machine</h3>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13</pre></td><td class="code"><pre><span class="gp">$ </span>qemu-system-ppc -machine <span class="nb">help
</span>Supported machines are:
40p                  IBM RS/6000 7020 <span class="o">(</span>40p<span class="o">)</span>
bamboo               bamboo
g3beige              Heathrow based PowerMAC <span class="o">(</span>default<span class="o">)</span>
mac99                Mac99 based PowerMAC
mpc8544ds            mpc8544ds
none                 empty machine
ppce500              generic paravirt e500 platform
prep                 PowerPC PREP platform
ref405ep             ref405ep
taihu                taihu
virtex-ml507         Xilinx Virtex ML507 reference design<span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="在makefile中添加配置选项">在Makefile中添加配置选项</h3>
<p>在PowerPC的默认配置选项中添加：</p>

<figure class="highlight"><pre><code class="language-make" data-lang="make"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre><span class="err">defaults-configs/ppc-softmmu.mak</span>

<span class="nv">CONFIG_VMC</span><span class="o">=</span><span class="err">y</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>在具体编译对象中添加：</p>

<figure class="highlight"><pre><code class="language-make" data-lang="make"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre><span class="err">hw/ppc/Makefile.objs</span>

<span class="c"># VMC
</span><span class="err">obj-$(CONFIG_VMC)</span> <span class="err">+=</span> <span class="err">vmc.o</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="添加machine源码">添加Machine源码</h3>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38</pre></td><td class="code"><pre><span class="n">hw</span><span class="o">/</span><span class="n">ppc</span><span class="o">/</span><span class="n">vmc</span><span class="p">.</span><span class="n">c</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">ppc_vmc_init</span><span class="p">(</span><span class="n">MachineState</span> <span class="o">*</span><span class="n">machine</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">...</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">heathrow_kvm_type</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* Always force PR KVM */</span>
    <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">vmc_class_init</span><span class="p">(</span><span class="n">ObjectClass</span> <span class="o">*</span><span class="n">oc</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">MachineClass</span> <span class="o">*</span><span class="n">mc</span> <span class="o">=</span> <span class="n">MACHINE_CLASS</span><span class="p">(</span><span class="n">oc</span><span class="p">);</span>

    <span class="n">mc</span><span class="o">-&gt;</span><span class="n">desc</span>               <span class="o">=</span> <span class="s">"VMC PowerPC 755"</span><span class="p">;</span>
    <span class="n">mc</span><span class="o">-&gt;</span><span class="n">init</span>               <span class="o">=</span> <span class="n">ppc_vmc_init</span><span class="p">;</span>
    <span class="n">mc</span><span class="o">-&gt;</span><span class="n">block_default_type</span> <span class="o">=</span> <span class="n">IF_PFLASH</span><span class="p">;</span>
    <span class="n">mc</span><span class="o">-&gt;</span><span class="n">max_cpus</span>           <span class="o">=</span> <span class="n">MAX_CPUS</span><span class="p">;</span>
    <span class="n">mc</span><span class="o">-&gt;</span><span class="n">default_boot_order</span> <span class="o">=</span> <span class="s">"cd"</span><span class="p">;</span>
    <span class="n">mc</span><span class="o">-&gt;</span><span class="n">kvm_type</span>           <span class="o">=</span> <span class="n">heathrow_kvm_type</span><span class="p">;</span>
    <span class="n">mc</span><span class="o">-&gt;</span><span class="n">default_cpu_type</span>   <span class="o">=</span> <span class="n">POWERPC_CPU_TYPE_NAME</span><span class="p">(</span><span class="s">"755_v2.8"</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">TypeInfo</span> <span class="n">ppc_vmc_machine_info</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">name</span>          <span class="o">=</span> <span class="n">MACHINE_TYPE_NAME</span><span class="p">(</span><span class="s">"VMC"</span><span class="p">),</span>
    <span class="p">.</span><span class="n">parent</span>        <span class="o">=</span> <span class="n">TYPE_MACHINE</span><span class="p">,</span>
    <span class="p">.</span><span class="n">class_init</span>    <span class="o">=</span> <span class="n">vmc_class_init</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ppc_vmc_register_types</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">type_register_static</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ppc_vmc_machine_info</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">type_init</span><span class="p">(</span><span class="n">ppc_vmc_register_types</span><span class="p">);</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>MachineClass结构体定义：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58</pre></td><td class="code"><pre><span class="n">include</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">boards</span><span class="p">.</span><span class="n">h</span>

<span class="k">struct</span> <span class="n">MachineClass</span> <span class="p">{</span>
    <span class="cm">/*&lt; private &gt;*/</span>
    <span class="n">ObjectClass</span> <span class="n">parent_class</span><span class="p">;</span>
    <span class="cm">/*&lt; public &gt;*/</span>

    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">family</span><span class="p">;</span> <span class="cm">/* NULL iff @name identifies a standalone machtype */</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">alias</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>

    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">init</span><span class="p">)(</span><span class="n">MachineState</span> <span class="o">*</span><span class="n">state</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">reset</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">hot_add_cpu</span><span class="p">)(</span><span class="k">const</span> <span class="kt">int64_t</span> <span class="n">id</span><span class="p">,</span> <span class="n">Error</span> <span class="o">**</span><span class="n">errp</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">kvm_type</span><span class="p">)(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>

    <span class="n">BlockInterfaceType</span> <span class="n">block_default_type</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">units_per_default_bus</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">max_cpus</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">min_cpus</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">default_cpus</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">no_serial</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">no_parallel</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">use_virtcon</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">use_sclp</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">no_floppy</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">no_cdrom</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">no_sdcard</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">has_dynamic_sysbus</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">pci_allow_0_address</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">legacy_fw_cfg_order</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">is_default</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">default_machine_opts</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">default_boot_order</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">default_display</span><span class="p">;</span>
    <span class="n">GArray</span> <span class="o">*</span><span class="n">compat_props</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hw_version</span><span class="p">;</span>
    <span class="n">ram_addr_t</span> <span class="n">default_ram_size</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">default_cpu_type</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">option_rom_has_mr</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">rom_file_has_mr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">minimum_page_bits</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">has_hotpluggable_cpus</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">ignore_memory_transaction_failures</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">numa_mem_align_shift</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">valid_cpu_types</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">auto_enable_numa_with_memhp</span><span class="p">;</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">numa_auto_assign_ram</span><span class="p">)(</span><span class="n">MachineClass</span> <span class="o">*</span><span class="n">mc</span><span class="p">,</span> <span class="n">NodeInfo</span> <span class="o">*</span><span class="n">nodes</span><span class="p">,</span>
                                 <span class="kt">int</span> <span class="n">nb_nodes</span><span class="p">,</span> <span class="n">ram_addr_t</span> <span class="n">size</span><span class="p">);</span>

    <span class="n">HotplugHandler</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">get_hotplug_handler</span><span class="p">)(</span><span class="n">MachineState</span> <span class="o">*</span><span class="n">machine</span><span class="p">,</span>
                                           <span class="n">DeviceState</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
    <span class="n">CpuInstanceProperties</span> <span class="p">(</span><span class="o">*</span><span class="n">cpu_index_to_instance_props</span><span class="p">)(</span><span class="n">MachineState</span> <span class="o">*</span><span class="n">machine</span><span class="p">,</span>
                                                         <span class="kt">unsigned</span> <span class="n">cpu_index</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">CPUArchIdList</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">possible_cpu_arch_ids</span><span class="p">)(</span><span class="n">MachineState</span> <span class="o">*</span><span class="n">machine</span><span class="p">);</span>
    <span class="kt">int64_t</span> <span class="p">(</span><span class="o">*</span><span class="n">get_default_cpu_node_id</span><span class="p">)(</span><span class="k">const</span> <span class="n">MachineState</span> <span class="o">*</span><span class="n">ms</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">);</span>
<span class="p">};</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>block_default_type的类型：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12</pre></td><td class="code"><pre><span class="n">include</span><span class="o">/</span><span class="n">sysemu</span><span class="o">/</span><span class="n">blockdev</span><span class="p">.</span><span class="n">h</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
    <span class="n">IF_DEFAULT</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>            <span class="cm">/* for use with drive_add() only */</span>
    <span class="cm">/*
     * IF_NONE must be zero, because we want MachineClass member
     * block_default_type to default-initialize to IF_NONE
     */</span>
    <span class="n">IF_NONE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">IF_IDE</span><span class="p">,</span> <span class="n">IF_SCSI</span><span class="p">,</span> <span class="n">IF_FLOPPY</span><span class="p">,</span> <span class="n">IF_PFLASH</span><span class="p">,</span> <span class="n">IF_MTD</span><span class="p">,</span> <span class="n">IF_SD</span><span class="p">,</span> <span class="n">IF_VIRTIO</span><span class="p">,</span> <span class="n">IF_XEN</span><span class="p">,</span>
    <span class="n">IF_COUNT</span>
<span class="p">}</span> <span class="n">BlockInterfaceType</span><span class="p">;</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="查看默认的cpu">查看默认的CPU</h3>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408</pre></td><td class="code"><pre><span class="gp">$ </span>qemu-system-ppc -cpu <span class="nb">help
</span>PowerPC 601_v1           PVR 00010001
PowerPC 601_v0           PVR 00010001
PowerPC 601_v2           PVR 00010002
PowerPC 601              <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>601_v2<span class="o">)</span>
PowerPC 601v             <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>601_v2<span class="o">)</span>
PowerPC 603              PVR 00030100
PowerPC mpc8240          <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>603<span class="o">)</span>
PowerPC vanilla          <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>603<span class="o">)</span>
PowerPC 604              PVR 00040103
PowerPC ppc32            <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>604<span class="o">)</span>
PowerPC ppc              <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>604<span class="o">)</span>
PowerPC default          <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>604<span class="o">)</span>
PowerPC 602              PVR 00050100
PowerPC 603e_v1.1        PVR 00060101
PowerPC 603e_v1.2        PVR 00060102
PowerPC 603e_v1.3        PVR 00060103
PowerPC 603e_v1.4        PVR 00060104
PowerPC 603e_v2.2        PVR 00060202
PowerPC 603e_v3          PVR 00060300
PowerPC 603e_v4          PVR 00060400
PowerPC 603e_v4.1        PVR 00060401
PowerPC 603e             <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>603e_v4.1<span class="o">)</span>
PowerPC stretch          <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>603e_v4.1<span class="o">)</span>
PowerPC 603p             PVR 00070000
PowerPC 603e7v           PVR 00070100
PowerPC vaillant         <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>603e7v<span class="o">)</span>
PowerPC 603e7v1          PVR 00070101
PowerPC 603e7            PVR 00070200
PowerPC 603e7v2          PVR 00070201
PowerPC 603e7t           PVR 00071201
PowerPC 603r             <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>603e7t<span class="o">)</span>
PowerPC goldeneye        <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>603e7t<span class="o">)</span>
PowerPC 750_v1.0         PVR 00080100
PowerPC 740_v1.0         PVR 00080100
PowerPC 740e             PVR 00080100
PowerPC 750e             PVR 00080200
PowerPC 750_v2.0         PVR 00080200
PowerPC 740_v2.0         PVR 00080200
PowerPC 750_v2.1         PVR 00080201
PowerPC 740_v2.1         PVR 00080201
PowerPC 740_v2.2         PVR 00080202
PowerPC 750_v2.2         PVR 00080202
PowerPC 750_v3.0         PVR 00080300
PowerPC 740_v3.0         PVR 00080300
PowerPC 750_v3.1         PVR 00080301
PowerPC 750              <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>750_v3.1<span class="o">)</span>
PowerPC typhoon          <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>750_v3.1<span class="o">)</span>
PowerPC g3               <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>750_v3.1<span class="o">)</span>
PowerPC 740_v3.1         PVR 00080301
PowerPC 740              <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>740_v3.1<span class="o">)</span>
PowerPC arthur           <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>740_v3.1<span class="o">)</span>
PowerPC 750cx_v1.0       PVR 00082100
PowerPC 750cx_v2.0       PVR 00082200
PowerPC 750cx_v2.1       PVR 00082201
PowerPC 750cx_v2.2       PVR 00082202
PowerPC 750cx            <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>750cx_v2.2<span class="o">)</span>
PowerPC 750cxe_v2.1      PVR 00082211
PowerPC 750cxe_v2.2      PVR 00082212
PowerPC 750cxe_v2.3      PVR 00082213
PowerPC 750cxe_v2.4      PVR 00082214
PowerPC 750cxe_v3.0      PVR 00082310
PowerPC 750cxe_v3.1      PVR 00082311
PowerPC 755_v1.0         PVR 00083100
PowerPC 745_v1.0         PVR 00083100
PowerPC 755_v1.1         PVR 00083101
PowerPC 745_v1.1         PVR 00083101
PowerPC 755_v2.0         PVR 00083200
PowerPC 745_v2.0         PVR 00083200
PowerPC 755_v2.1         PVR 00083201
PowerPC 745_v2.1         PVR 00083201
PowerPC 745_v2.2         PVR 00083202
PowerPC 755_v2.2         PVR 00083202
PowerPC 755_v2.3         PVR 00083203
PowerPC 745_v2.3         PVR 00083203
PowerPC 755_v2.4         PVR 00083204
PowerPC 745_v2.4         PVR 00083204
PowerPC 745_v2.5         PVR 00083205
PowerPC 755_v2.5         PVR 00083205
PowerPC 755_v2.6         PVR 00083206
PowerPC 745_v2.6         PVR 00083206
PowerPC 755_v2.7         PVR 00083207
PowerPC 745_v2.7         PVR 00083207
PowerPC 745_v2.8         PVR 00083208
PowerPC 745              <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>745_v2.8<span class="o">)</span>
PowerPC 755_v2.8         PVR 00083208
PowerPC 755              <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>755_v2.8<span class="o">)</span>
PowerPC goldfinger       <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>755_v2.8<span class="o">)</span>
PowerPC 750cxe_v2.4b     PVR 00083214
PowerPC 750cxe_v3.1b     PVR 00083311
PowerPC 750cxe           <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>750cxe_v3.1b<span class="o">)</span>
PowerPC 750cxr           PVR 00083410
PowerPC 750cl_v1.0       PVR 00087200
PowerPC 750cl_v2.0       PVR 00087210
PowerPC 750cl            <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>750cl_v2.0<span class="o">)</span>
PowerPC 750l_v2.0        PVR 00088200
PowerPC 750l_v2.1        PVR 00088201
PowerPC 750l_v2.2        PVR 00088202
PowerPC 750l_v3.0        PVR 00088300
PowerPC 750l_v3.2        PVR 00088302
PowerPC 750l             <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>750l_v3.2<span class="o">)</span>
PowerPC lonestar         <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>750l_v3.2<span class="o">)</span>
PowerPC 604e_v1.0        PVR 00090100
PowerPC 604e_v2.2        PVR 00090202
PowerPC 604e_v2.4        PVR 00090204
PowerPC 604e             <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>604e_v2.4<span class="o">)</span>
PowerPC sirocco          <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>604e_v2.4<span class="o">)</span>
PowerPC 604r             PVR 000a0101
PowerPC mach5            <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>604r<span class="o">)</span>
PowerPC 7400_v1.0        PVR 000c0100
PowerPC 7400_v1.1        PVR 000c0101
PowerPC 7400_v2.0        PVR 000c0200
PowerPC 7400_v2.1        PVR 000c0201
PowerPC 7400_v2.2        PVR 000c0202
PowerPC 7400_v2.6        PVR 000c0206
PowerPC 7400_v2.7        PVR 000c0207
PowerPC 7400_v2.8        PVR 000c0208
PowerPC 7400_v2.9        PVR 000c0209
PowerPC 7400             <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>7400_v2.9<span class="o">)</span>
PowerPC max              <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>7400_v2.9<span class="o">)</span>
PowerPC g4               <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>7400_v2.9<span class="o">)</span>
PowerPC 403ga            PVR 00200011
PowerPC 403gb            PVR 00200100
PowerPC 403gc            PVR 00200200
PowerPC 403              <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>403gc<span class="o">)</span>
PowerPC 403gcx           PVR 00201400
PowerPC 401a1            PVR 00210000
PowerPC 401b2            PVR 00220000
PowerPC iop480           PVR 00220000
PowerPC 401c2            PVR 00230000
PowerPC 401d2            PVR 00240000
PowerPC 401e2            PVR 00250000
PowerPC 401f2            PVR 00260000
PowerPC 401g2            PVR 00270000
PowerPC 401              PVR 00270000
PowerPC g2               PVR 00810011
PowerPC mpc603           PVR 00810100
PowerPC g2hip3           PVR 00810101
PowerPC mpc8250_hip3     <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>g2hip3<span class="o">)</span>
PowerPC mpc8255_hip3     <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>g2hip3<span class="o">)</span>
PowerPC mpc8260_hip3     <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>g2hip3<span class="o">)</span>
PowerPC mpc8264_hip3     <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>g2hip3<span class="o">)</span>
PowerPC mpc8265_hip3     <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>g2hip3<span class="o">)</span>
PowerPC mpc8266_hip3     <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>g2hip3<span class="o">)</span>
PowerPC mpc8349a         PVR 00830010
PowerPC mpc8347ap        PVR 00830010
PowerPC mpc8347eap       PVR 00830010
PowerPC mpc8347p         PVR 00830010
PowerPC mpc8349          PVR 00830010
PowerPC mpc8343e         PVR 00830010
PowerPC mpc8343ea        PVR 00830010
PowerPC mpc8343          PVR 00830010
PowerPC mpc8347et        PVR 00830010
PowerPC mpc8347e         <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>mpc8347et<span class="o">)</span>
PowerPC mpc8349e         PVR 00830010
PowerPC mpc8347at        PVR 00830010
PowerPC mpc8347a         <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>mpc8347at<span class="o">)</span>
PowerPC mpc8349ea        PVR 00830010
PowerPC mpc8347eat       PVR 00830010
PowerPC mpc8347ea        <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>mpc8347eat<span class="o">)</span>
PowerPC mpc8343a         PVR 00830010
PowerPC mpc8347t         PVR 00830010
PowerPC mpc8347          <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>mpc8347t<span class="o">)</span>
PowerPC mpc8347ep        PVR 00830010
PowerPC e300c1           PVR 00830010
PowerPC e300c2           PVR 00840010
PowerPC e300c3           PVR 00850010
PowerPC e300             <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>e300c3<span class="o">)</span>
PowerPC mpc8379          PVR 00860010
PowerPC mpc8378e         PVR 00860010
PowerPC mpc8379e         PVR 00860010
PowerPC mpc8378          PVR 00860010
PowerPC mpc8377          PVR 00860010
PowerPC e300c4           PVR 00860010
PowerPC mpc8377e         PVR 00860010
PowerPC 750p             PVR 10080000
PowerPC conan/doyle      <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>750p<span class="o">)</span>
PowerPC 740p             PVR 10080000
PowerPC cobra            PVR 10100000
PowerPC 460exb           PVR 130218a4
PowerPC 460ex            <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>460exb<span class="o">)</span>
PowerPC 440epx           PVR 200008d0
PowerPC 405d2            PVR 20010000
PowerPC x2vp4            PVR 20010820
PowerPC x2vp7            <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>x2vp4<span class="o">)</span>
PowerPC x2vp20           PVR 20010860
PowerPC x2vp50           <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>x2vp20<span class="o">)</span>
PowerPC 405gpa           PVR 40110000
PowerPC 405gpb           PVR 40110040
PowerPC 405cra           PVR 40110041
PowerPC 405gpc           PVR 40110082
PowerPC 405gpd           PVR 401100c4
PowerPC 405gp            <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>405gpd<span class="o">)</span>
PowerPC 405crb           PVR 401100c5
PowerPC 405crc           PVR 40110145
PowerPC 405cr            <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>405crc<span class="o">)</span>
PowerPC 405gpe           <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>405crc<span class="o">)</span>
PowerPC stb03            PVR 40310000
PowerPC npe4gs3          PVR 40b10000
PowerPC npe405h          PVR 414100c0
PowerPC npe405h2         PVR 41410140
PowerPC 405ez            PVR 41511460
PowerPC npe405l          PVR 416100c0
PowerPC 405d4            PVR 41810000
PowerPC 405              <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>405d4<span class="o">)</span>
PowerPC stb04            PVR 41810000
PowerPC 405lp            PVR 41f10000
PowerPC 440epa           PVR 42221850
PowerPC 440epb           PVR 422218d3
PowerPC 440ep            <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>440epb<span class="o">)</span>
PowerPC 405gpr           PVR 50910951
PowerPC 405ep            PVR 51210950
PowerPC stb25            PVR 51510950
PowerPC 750fx_v1.0       PVR 70000100
PowerPC 750fx_v2.0       PVR 70000200
PowerPC 750fx_v2.1       PVR 70000201
PowerPC 750fx_v2.2       PVR 70000202
PowerPC 750fl            PVR 70000203
PowerPC 750fx_v2.3       PVR 70000203
PowerPC 750fx            <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>750fx_v2.3<span class="o">)</span>
PowerPC 750gx_v1.0       PVR 70020100
PowerPC 750gx_v1.1       PVR 70020101
PowerPC 750gx_v1.2       PVR 70020102
PowerPC 750gx            <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>750gx_v1.2<span class="o">)</span>
PowerPC 750gl            PVR 70020102
PowerPC 440-xilinx       PVR 7ff21910
PowerPC 440-xilinx-w-dfpu PVR 7ff21910
PowerPC 7450_v1.0        PVR 80000100
PowerPC 7450_v1.1        PVR 80000101
PowerPC 7450_v1.2        PVR 80000102
PowerPC 7450_v2.0        PVR 80000200
PowerPC 7450_v2.1        PVR 80000201
PowerPC 7450             <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>7450_v2.1<span class="o">)</span>
PowerPC vger             <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>7450_v2.1<span class="o">)</span>
PowerPC 7441_v2.1        PVR 80000201
PowerPC 7441_v2.3        PVR 80000203
PowerPC 7441             <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>7441_v2.3<span class="o">)</span>
PowerPC 7451_v2.3        PVR 80000203
PowerPC 7451             <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>7451_v2.3<span class="o">)</span>
PowerPC 7451_v2.10       PVR 80000210
PowerPC 7441_v2.10       PVR 80000210
PowerPC 7455_v1.0        PVR 80010100
PowerPC 7445_v1.0        PVR 80010100
PowerPC 7445_v2.1        PVR 80010201
PowerPC 7455_v2.1        PVR 80010201
PowerPC 7445_v3.2        PVR 80010302
PowerPC 7445             <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>7445_v3.2<span class="o">)</span>
PowerPC 7455_v3.2        PVR 80010302
PowerPC 7455             <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>7455_v3.2<span class="o">)</span>
PowerPC apollo6          <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>7455_v3.2<span class="o">)</span>
PowerPC 7455_v3.3        PVR 80010303
PowerPC 7445_v3.3        PVR 80010303
PowerPC 7455_v3.4        PVR 80010304
PowerPC 7445_v3.4        PVR 80010304
PowerPC 7447_v1.0        PVR 80020100
PowerPC 7457_v1.0        PVR 80020100
PowerPC 7457_v1.1        PVR 80020101
PowerPC 7447_v1.1        PVR 80020101
PowerPC 7447             <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>7447_v1.1<span class="o">)</span>
PowerPC 7457_v1.2        PVR 80020102
PowerPC 7457             <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>7457_v1.2<span class="o">)</span>
PowerPC apollo7          <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>7457_v1.2<span class="o">)</span>
PowerPC 7457a_v1.0       PVR 80030100
PowerPC apollo7pm        <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>7457a_v1.0<span class="o">)</span>
PowerPC 7447a_v1.0       PVR 80030100
PowerPC 7447a_v1.1       PVR 80030101
PowerPC 7457a_v1.1       PVR 80030101
PowerPC 7447a_v1.2       PVR 80030102
PowerPC 7447a            <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>7447a_v1.2<span class="o">)</span>
PowerPC 7457a_v1.2       PVR 80030102
PowerPC 7457a            <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>7457a_v1.2<span class="o">)</span>
PowerPC e600             PVR 80040010
PowerPC mpc8610          PVR 80040010
PowerPC mpc8641d         PVR 80040010
PowerPC mpc8641          PVR 80040010
PowerPC 7448_v1.0        PVR 80040100
PowerPC 7448_v1.1        PVR 80040101
PowerPC 7448_v2.0        PVR 80040200
PowerPC 7448_v2.1        PVR 80040201
PowerPC 7448             <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>7448_v2.1<span class="o">)</span>
PowerPC 7410_v1.0        PVR 800c1100
PowerPC 7410_v1.1        PVR 800c1101
PowerPC 7410_v1.2        PVR 800c1102
PowerPC 7410_v1.3        PVR 800c1103
PowerPC 7410_v1.4        PVR 800c1104
PowerPC 7410             <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>7410_v1.4<span class="o">)</span>
PowerPC nitro            <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>7410_v1.4<span class="o">)</span>
PowerPC e500_v10         PVR 80200010
PowerPC mpc8540_v10      PVR 80200010
PowerPC mpc8540_v21      PVR 80200020
PowerPC mpc8540          <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>mpc8540_v21<span class="o">)</span>
PowerPC e500_v20         PVR 80200020
PowerPC e500v1           <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>e500_v20<span class="o">)</span>
PowerPC mpc8541_v10      PVR 80200020
PowerPC mpc8541e_v11     PVR 80200020
PowerPC mpc8541e         <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>mpc8541e_v11<span class="o">)</span>
PowerPC mpc8540_v20      PVR 80200020
PowerPC mpc8541e_v10     PVR 80200020
PowerPC mpc8541_v11      PVR 80200020
PowerPC mpc8541          <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>mpc8541_v11<span class="o">)</span>
PowerPC mpc8555_v10      PVR 80210010
PowerPC mpc8548_v10      PVR 80210010
PowerPC mpc8543_v10      PVR 80210010
PowerPC mpc8543e_v10     PVR 80210010
PowerPC mpc8548e_v10     PVR 80210010
PowerPC mpc8555e_v10     PVR 80210010
PowerPC e500v2_v10       PVR 80210010
PowerPC mpc8560_v10      PVR 80210010
PowerPC mpc8543e_v11     PVR 80210011
PowerPC mpc8548e_v11     PVR 80210011
PowerPC mpc8555e_v11     PVR 80210011
PowerPC mpc8555e         <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>mpc8555e_v11<span class="o">)</span>
PowerPC mpc8555_v11      PVR 80210011
PowerPC mpc8555          <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>mpc8555_v11<span class="o">)</span>
PowerPC mpc8548_v11      PVR 80210011
PowerPC mpc8543_v11      PVR 80210011
PowerPC mpc8547e_v20     PVR 80210020
PowerPC e500v2_v20       PVR 80210020
PowerPC mpc8560_v20      PVR 80210020
PowerPC mpc8545e_v20     PVR 80210020
PowerPC mpc8545_v20      PVR 80210020
PowerPC mpc8548_v20      PVR 80210020
PowerPC mpc8543_v20      PVR 80210020
PowerPC mpc8543e_v20     PVR 80210020
PowerPC mpc8548e_v20     PVR 80210020
PowerPC mpc8545_v21      PVR 80210021
PowerPC mpc8545          <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>mpc8545_v21<span class="o">)</span>
PowerPC mpc8548_v21      PVR 80210021
PowerPC mpc8548          <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>mpc8548_v21<span class="o">)</span>
PowerPC mpc8543_v21      PVR 80210021
PowerPC mpc8543          <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>mpc8543_v21<span class="o">)</span>
PowerPC mpc8544_v10      PVR 80210021
PowerPC mpc8543e_v21     PVR 80210021
PowerPC mpc8543e         <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>mpc8543e_v21<span class="o">)</span>
PowerPC mpc8544e_v10     PVR 80210021
PowerPC mpc8533_v10      PVR 80210021
PowerPC mpc8548e_v21     PVR 80210021
PowerPC mpc8548e         <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>mpc8548e_v21<span class="o">)</span>
PowerPC mpc8547e_v21     PVR 80210021
PowerPC mpc8547e         <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>mpc8547e_v21<span class="o">)</span>
PowerPC mpc8560_v21      PVR 80210021
PowerPC mpc8560          <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>mpc8560_v21<span class="o">)</span>
PowerPC e500v2_v21       PVR 80210021
PowerPC mpc8533e_v10     PVR 80210021
PowerPC mpc8545e_v21     PVR 80210021
PowerPC mpc8545e         <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>mpc8545e_v21<span class="o">)</span>
PowerPC mpc8533_v11      PVR 80210022
PowerPC mpc8533          <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>mpc8533_v11<span class="o">)</span>
PowerPC mpc8567e         PVR 80210022
PowerPC e500v2_v22       PVR 80210022
PowerPC e500             <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>e500v2_v22<span class="o">)</span>
PowerPC e500v2           <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>e500v2_v22<span class="o">)</span>
PowerPC mpc8533e_v11     PVR 80210022
PowerPC mpc8533e         <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>mpc8533e_v11<span class="o">)</span>
PowerPC mpc8568e         PVR 80210022
PowerPC mpc8568          PVR 80210022
PowerPC mpc8567          PVR 80210022
PowerPC mpc8544e_v11     PVR 80210022
PowerPC mpc8544e         <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>mpc8544e_v11<span class="o">)</span>
PowerPC mpc8544_v11      PVR 80210022
PowerPC mpc8544          <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>mpc8544_v11<span class="o">)</span>
PowerPC e500v2_v30       PVR 80210030
PowerPC mpc8572e         PVR 80210030
PowerPC mpc8572          PVR 80210030
PowerPC e500mc           PVR 80230020
PowerPC g2h4             PVR 80811010
PowerPC g2hip4           PVR 80811014
PowerPC mpc8241          <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>g2hip4<span class="o">)</span>
PowerPC mpc8245          <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>g2hip4<span class="o">)</span>
PowerPC mpc8250          <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>g2hip4<span class="o">)</span>
PowerPC mpc8250_hip4     <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>g2hip4<span class="o">)</span>
PowerPC mpc8255          <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>g2hip4<span class="o">)</span>
PowerPC mpc8255_hip4     <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>g2hip4<span class="o">)</span>
PowerPC mpc8260          <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>g2hip4<span class="o">)</span>
PowerPC mpc8260_hip4     <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>g2hip4<span class="o">)</span>
PowerPC mpc8264          <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>g2hip4<span class="o">)</span>
PowerPC mpc8264_hip4     <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>g2hip4<span class="o">)</span>
PowerPC mpc8265          <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>g2hip4<span class="o">)</span>
PowerPC mpc8265_hip4     <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>g2hip4<span class="o">)</span>
PowerPC mpc8266          <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>g2hip4<span class="o">)</span>
PowerPC mpc8266_hip4     <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>g2hip4<span class="o">)</span>
PowerPC g2le             PVR 80820010
PowerPC g2gp             PVR 80821010
PowerPC g2legp           PVR 80822010
PowerPC mpc5200_v10      PVR 80822011
PowerPC mpc5200_v12      PVR 80822011
PowerPC mpc52xx          <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>mpc5200_v12<span class="o">)</span>
PowerPC mpc5200          <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>mpc5200_v12<span class="o">)</span>
PowerPC g2legp1          PVR 80822011
PowerPC mpc5200_v11      PVR 80822011
PowerPC mpc5200b_v21     PVR 80822011
PowerPC mpc5200b         <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>mpc5200b_v21<span class="o">)</span>
PowerPC mpc5200b_v20     PVR 80822011
PowerPC g2legp3          PVR 80822013
PowerPC mpc82xx          <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>g2legp3<span class="o">)</span>
PowerPC powerquicc-ii    <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>g2legp3<span class="o">)</span>
PowerPC mpc8247          <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>g2legp3<span class="o">)</span>
PowerPC mpc8248          <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>g2legp3<span class="o">)</span>
PowerPC mpc8270          <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>g2legp3<span class="o">)</span>
PowerPC mpc8271          <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>g2legp3<span class="o">)</span>
PowerPC mpc8272          <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>g2legp3<span class="o">)</span>
PowerPC mpc8275          <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>g2legp3<span class="o">)</span>
PowerPC mpc8280          <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>g2legp3<span class="o">)</span>
PowerPC e200z5           PVR 81000000
PowerPC e200z6           PVR 81120000
PowerPC e200             <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>e200z6<span class="o">)</span>
PowerPC g2ls             PVR 90810010
PowerPC g2lels           PVR a0822010<span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

]]></content:encoded>
    </item>
    
    <item>
      <title>QEMU Configure</title>
      <link href="/2018/04/qemu-configure/"/>
      <pubDate>2018-04-26T00:00:00+08:00</pubDate>
      <author>maow</author>
      <guid>/2018/04/qemu-configure</guid>
      <content:encoded><![CDATA[<p>本文主要分析QEMU的Configure</p>

<h1 id="fdt">FDT</h1>
<p>FDT (Flat device tree)，可以参考 htttp://devicetree.org/Device_Tree_Usage，
https://blog.csdn.net/cosmoslhf/article/details/49364577，
http://www.wowotech.net/linux_kenrel/why-dt.html</p>

<h1 id="capstone">capstone</h1>
<p>Capstone is a disassembly framework with the target of becoming the ultimate
disasm engine for binary analysis and reversing in the security community.</p>

<p>Capstone：用于二进制分析和反转的反汇编框架，支持多种语言的许多架构和绑定。
https://github.com/aquynh/capstone</p>

<h1 id="sparse">sparse</h1>

<h1 id="gnutls">gnutls</h1>
<p>GNUTLS cryptography support</p>

<h1 id="nettle">nettle</h1>
<p>nettle cryptography support</p>

<h1 id="curses">curses</h1>
<p>curses UI</p>

<h1 id="smpnumampp">SMP/NUMA/MPP</h1>
<p><a href="http://www.cnblogs.com/yubo/archive/2010/04/
23/1718810.html">SMP、NUMA、MPP体系结构介绍</a></p>

<p>SMP, Symmetric Multi-Processor，对称多处理器结构：对称多处理系统内有许多紧耦合
多处理器，在这样的系统中，所有的CPU共享全部资源，如总线，内存和I/O系统等，操作系统或
管理数据库的复本只有一个，这种系统有一个最大的特点就是共享所有资源。多个CPU之间没有区别，
平等地访问内存、外设、一个操作系统。操作系统管理着一个队列，每个处理器依次处理队列中的
进程。如果两个处理器同时请求访问一个资源（例如同一段内存地址），由硬件、软件的锁机制去
解决资源争用问题。</p>

<p><img src="/pictures/SMP.svg" alt="SMP" /></p>

<p>所谓对称多处理器结构，是指服务器中多个 CPU 对称工作，无主次或从属关系。各 CPU 共享
相同的物理内存，每个 CPU 访问内存中的任何地址所需时间是相同的，因此 SMP 也被称为
一致存储器访问结构 (UMA ： Uniform Memory Access) 。对 SMP 服务器进行扩展的方式
包括增加内存、使用更快的 CPU 、增加 CPU 、扩充 I/O( 槽口数与总线数 ) 以及添加更多的
外部设备 ( 通常是磁盘存储 ) 。</p>

<p>SMP 服务器的主要特征是共享，系统中所有资源 (CPU 、内存、 I/O 等 ) 都是共享的。也正是
由于这种特征，导致了 SMP 服务器的主要问题，那就是它的扩展能力非常有限。对于 SMP 服务器
而言，每一个共享的环节都可能造成 SMP 服务器扩展时的瓶颈，而最受限制的则是内存。由于
每个 CPU 必须通过相同的内存总线访问相同的内存资源，因此随着 CPU 数量的增加，内存访问冲突
将迅速增加，最终会造成 CPU 资源的浪费，使 CPU 性能的有效性大大降低。实验证明，
SMP 服务器 CPU 利用率最好的情况是 2 至 4 个 CPU 。</p>

<p>NUMA, Non-Uniform Memory Access，非一致存储访问结构：由于 SMP 在扩展能力上的限制，
人们开始探究如何进行有效地扩展从而构建大型系统的技术， NUMA 就是这种努力下的结果之一。
利用 NUMA 技术，可以把几十个 CPU( 甚至上百个 CPU) 组合在一个服务器内。</p>

<p>NUMA 服务器的基本特征是具有多个 CPU 模块，每个 CPU 模块由多个 CPU( 如 4 个 ) 组成，
并且具有独立的本地内存、 I/O 槽口等。由于其节点之间可以通过互联模块 ( 如称为
Crossbar Switch) 进行连接和信息交互，因此每个 CPU 可以访问整个系统的内存 (
这是 NUMA 系统与 MPP 系统的重要差别 ) 。显然，访问本地内存的速度将远远高于
访问远地内存 ( 系统内其它节点的内存 ) 的速度，这也是非一致存储访问 NUMA 的由来。
由于这个特点，为了更好地发挥系统性能，开发应用程序时需要尽量减少不同 CPU 模块之间的
信息交互。</p>

<p>利用 NUMA 技术，可以较好地解决原来 SMP 系统的扩展问题，在一个物理服务器内可以支持
上百个 CPU 。比较典型的 NUMA 服务器的例子包括 HP 的 Superdome 、 SUN15K 、
IBMp690 等。</p>

<p>但 NUMA 技术同样有一定缺陷，由于访问远地内存的延时远远超过本地内存，因此当 CPU
数量增加时，系统性能无法线性增加。如 HP 公司发布 Superdome 服务器时，曾公布了它
与 HP 其它 UNIX 服务器的相对性能值，结果发现， 64 路 CPU 的 Superdome (NUMA 结构 )
的相对性能值是 20 ，而 8 路 N4000( 共享的 SMP 结构 ) 的相对性能值是 6.3 。从这个结果
可以看到， 8 倍数量的 CPU 换来的只是 3 倍性能的提升。</p>

<p>MPP, Massive Parallel Processing，海量并行处理结构：和 NUMA 不同， MPP 提供了另外
一种进行系统扩展的方式，它由多个 SMP 服务器通过一定的节点互联网络进行连接，协同工作，
完成相同的任务，从用户的角度来看是一个服务器系统。其基本特征是由多个 SMP 服务器 (
每个 SMP 服务器称节点 ) 通过节点互联网络连接而成，每个节点只访问自己的本地资源 (
内存、存储等 ) ，是一种完全无共享 (Share Nothing) 结构，因而扩展能力最好，理论上
其扩展无限制，目前的技术可实现 512 个节点互联，数千个 CPU 。目前业界对节点互联网络
暂无标准，如 NCR 的 Bynet ， IBM 的 SPSwitch ，它们都采用了不同的内部实现机制。
但节点互联网仅供 MPP 服务器内部使用，对用户而言是透明的。</p>

<p>在 MPP 系统中，每个 SMP 节点也可以运行自己的操作系统、数据库等。但和 NUMA 不同的是，
它不存在异地内存访问的问题。换言之，每个节点内的 CPU 不能访问另一个节点的内存。节点
之间的信息交互是通过节点互联网络实现的，这个过程一般称为数据重分配
(Data Redistribution) 。</p>

<p>但是 MPP 服务器需要一种复杂的机制来调度和平衡各个节点的负载和并行处理过程。目前一些
基于 MPP 技术的服务器往往通过系统级软件 ( 如数据库 ) 来屏蔽这种复杂性。举例来说，
NCR 的 Teradata 就是基于 MPP 技术的一个关系数据库软件，基于此数据库来开发应用时，
不管后台服务器由多少个节点组成，开发人员所面对的都是同一个数据库系统，而不需要考虑
如何调度其中某几个节点的负载。</p>

<p>MPP (Massively Parallel Processing)，大规模并行处理系统，这样的系统是由许多
松耦合的处理单元组成的，要注意的是这里指的是处理单元而不是处理器。每个单元内的CPU
都有自己私有的资源，如总线，内存，硬盘等。在每个单元内都有操作系统和管理数据库的
实例复本。这种结构最大的特点在于不共享资源。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>QEMU Module Infrastructure</title>
      <link href="/2018/04/qemu-module/"/>
      <pubDate>2018-04-18T00:00:00+08:00</pubDate>
      <author>maow</author>
      <guid>/2018/04/qemu-module</guid>
      <content:encoded><![CDATA[<p>本文主要分析QEMU的Module框架机制</p>

<h1 id="qemu-module-infrastructure">QEMU Module Infrastructure</h1>
<p>相关的Maintainer是IBM的Anthony Liguori (aliguori@us.ibm.com)。</p>

<h2 id="module初始化">Module初始化</h2>

<h3 id="源码">源码</h3>
<p>定义了4种Module: BLOCK,OPTS,QOM,TRACE，其定义如下:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9</pre></td><td class="code"><pre><span class="n">include</span><span class="o">/</span><span class="n">qemu</span><span class="o">/</span><span class="n">module</span><span class="p">.</span><span class="n">h</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
    <span class="n">MODULE_INIT_BLOCK</span><span class="p">,</span>
    <span class="n">MODULE_INIT_OPTS</span><span class="p">,</span>
    <span class="n">MODULE_INIT_QOM</span><span class="p">,</span>
    <span class="n">MODULE_INIT_TRACE</span><span class="p">,</span>
    <span class="n">MODULE_INIT_MAX</span>
<span class="p">}</span> <span class="n">module_init_type</span><span class="p">;</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>针对每种Module的初始化接口，都是C语言的宏:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12</pre></td><td class="code"><pre><span class="n">include</span><span class="o">/</span><span class="n">qemu</span><span class="o">/</span><span class="n">module</span><span class="p">.</span><span class="n">h</span>

<span class="cp">#define block_init(function) module_init(function, MODULE_INIT_BLOCK)
#define opts_init(function) module_init(function, MODULE_INIT_OPTS)
#define type_init(function) module_init(function, MODULE_INIT_QOM)
#define trace_init(function) module_init(function, MODULE_INIT_TRACE)
</span>
<span class="cp">#define module_init(function, type)                                         \
static void __attribute__((constructor)) do_qemu_init_ ## function(void)    \
{                                                                           \
    register_module_init(function, type);                                   \
}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="type_init源码分析">type_init()源码分析</h3>
<p>对应代码，对于每个type_init()都会生成一个对应的构造函数：
<img src="/pictures/qemu-module-01.svg" alt="函数调用流" /></p>

<h3 id="构造函数">构造函数</h3>
<p>这个是利用了GNU Compiler Collection (GCC)的扩展属性，”GCC 7.3 Manual” -&gt;
“6 Extensions to the C Language Family” -&gt; “6.31 Declaring Attributes of
Functions” -&gt; “6.31.1 Common Function Attributes”</p>

<blockquote>
  <p>The <strong>constructor</strong> attribute causes the function to be called automatically
before execution enters main (). Similarly, the destructor attribute causes
the function to be called automatically after main () completes or exit ()
is called. Functions with these attributes are useful for initializing data
that is used implicitly during the execution of the program.</p>
</blockquote>

<h3 id="源码-1">源码</h3>
<p>其register_module_init()函数定义如下:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54</pre></td><td class="code"><pre><span class="n">util</span><span class="o">/</span><span class="n">module</span><span class="p">.</span><span class="n">c</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ModuleEntry</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">init</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
    <span class="n">QTAILQ_ENTRY</span><span class="p">(</span><span class="n">ModuleEntry</span><span class="p">)</span> <span class="n">node</span><span class="p">;</span>
    <span class="n">module_init_type</span> <span class="n">type</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ModuleEntry</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">QTAILQ_HEAD</span><span class="p">(,</span> <span class="n">ModuleEntry</span><span class="p">)</span> <span class="n">ModuleTypeList</span><span class="p">;</span>

<span class="k">static</span> <span class="n">ModuleTypeList</span> <span class="n">init_type_list</span><span class="p">[</span><span class="n">MODULE_INIT_MAX</span><span class="p">];</span>

<span class="k">static</span> <span class="n">ModuleTypeList</span> <span class="n">dso_init_list</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_lists</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">inited</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">inited</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MODULE_INIT_MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">QTAILQ_INIT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_type_list</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="n">QTAILQ_INIT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dso_init_list</span><span class="p">);</span>

    <span class="n">inited</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="n">ModuleTypeList</span> <span class="o">*</span><span class="nf">find_type</span><span class="p">(</span><span class="n">module_init_type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">init_lists</span><span class="p">();</span>

    <span class="k">return</span> <span class="o">&amp;</span><span class="n">init_type_list</span><span class="p">[</span><span class="n">type</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">register_module_init</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">void</span><span class="p">),</span> <span class="n">module_init_type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ModuleEntry</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>
    <span class="n">ModuleTypeList</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>

    <span class="n">e</span> <span class="o">=</span> <span class="n">g_malloc0</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">));</span>
    <span class="n">e</span><span class="o">-&gt;</span><span class="n">init</span> <span class="o">=</span> <span class="n">fn</span><span class="p">;</span>
    <span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>

    <span class="n">l</span> <span class="o">=</span> <span class="n">find_type</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>

    <span class="n">QTAILQ_INSERT_TAIL</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="do_qemu_init_xxx代码分析">do_qemu_init_xxx()代码分析</h3>
<p>每个构造函数都由OS在main之前调用： <img src="/pictures/qemu-module-02.svg" alt="函数调用流" /></p>

<p>每个构造函数生成一个节点，放入func和type，然后把节点插入到type对应的队列中。
数据结构为： <img src="/pictures/qemu-module-03.svg" alt="数据结构" /></p>

<h2 id="module注册">Module注册</h2>

<h3 id="源码-2">源码</h3>
<p>苹果的G3机器注册：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14</pre></td><td class="code"><pre><span class="n">hw</span><span class="o">/</span><span class="n">ppc</span><span class="o">/</span><span class="n">mac_oldworld</span><span class="p">.</span><span class="n">c</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">TypeInfo</span> <span class="n">ppc_heathrow_machine_info</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">name</span>          <span class="o">=</span> <span class="n">MACHINE_TYPE_NAME</span><span class="p">(</span><span class="s">"g3beige"</span><span class="p">),</span>
    <span class="p">.</span><span class="n">parent</span>        <span class="o">=</span> <span class="n">TYPE_MACHINE</span><span class="p">,</span>
    <span class="p">.</span><span class="n">class_init</span>    <span class="o">=</span> <span class="n">heathrow_class_init</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ppc_heathrow_register_types</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">type_register_static</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ppc_heathrow_machine_info</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">type_init</span><span class="p">(</span><span class="n">ppc_heathrow_register_types</span><span class="p">);</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>苹果的G5机器注册：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12</pre></td><td class="code"><pre><span class="k">static</span> <span class="k">const</span> <span class="n">TypeInfo</span> <span class="n">core99_machine_info</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">name</span>          <span class="o">=</span> <span class="n">MACHINE_TYPE_NAME</span><span class="p">(</span><span class="s">"mac99"</span><span class="p">),</span>
    <span class="p">.</span><span class="n">parent</span>        <span class="o">=</span> <span class="n">TYPE_MACHINE</span><span class="p">,</span>
    <span class="p">.</span><span class="n">class_init</span>    <span class="o">=</span> <span class="n">core99_machine_class_init</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mac_machine_register_types</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">type_register_static</span><span class="p">(</span><span class="o">&amp;</span><span class="n">core99_machine_info</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">type_init</span><span class="p">(</span><span class="n">mac_machine_register_types</span><span class="p">)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>PowerPC的硬件参考平台注册：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre><span class="n">hw</span><span class="o">/</span><span class="n">ppc</span><span class="o">/</span><span class="n">prep</span><span class="p">.</span><span class="n">c</span>

<span class="n">DEFINE_MACHINE</span><span class="p">(</span><span class="s">"prep"</span><span class="p">,</span> <span class="n">prep_machine_init</span><span class="p">)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>其中的DEFINE_MACHINE()宏：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18</pre></td><td class="code"><pre><span class="n">include</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">boards</span><span class="p">.</span><span class="n">h</span>

<span class="cp">#define DEFINE_MACHINE(namestr, machine_initfn) \
    static void machine_initfn##_class_init(ObjectClass *oc, void *data) \
    { \
        MachineClass *mc = MACHINE_CLASS(oc); \
        machine_initfn(mc); \
    } \
    static const TypeInfo machine_initfn##_typeinfo = { \
        .name       = MACHINE_TYPE_NAME(namestr), \
        .parent     = TYPE_MACHINE, \
        .class_init = machine_initfn##_class_init, \
    }; \
    static void machine_initfn##_register_types(void) \
    { \
        type_register_static(&amp;machine_initfn##_typeinfo); \
    } \
    type_init(machine_initfn##_register_types)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>而其中的内部注册函数：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58</pre></td><td class="code"><pre><span class="n">qom</span><span class="o">/</span><span class="n">object</span><span class="p">.</span><span class="n">c</span>

<span class="k">static</span> <span class="n">TypeImpl</span> <span class="o">*</span><span class="n">type_new</span><span class="p">(</span><span class="k">const</span> <span class="n">TypeInfo</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">TypeImpl</span> <span class="o">*</span><span class="n">ti</span> <span class="o">=</span> <span class="n">g_malloc0</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ti</span><span class="p">));</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

    <span class="n">g_assert</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">type_table_lookup</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Registering `%s' which already exists</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
        <span class="n">abort</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">ti</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">g_strdup</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
    <span class="n">ti</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">g_strdup</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>

    <span class="n">ti</span><span class="o">-&gt;</span><span class="n">class_size</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">class_size</span><span class="p">;</span>
    <span class="n">ti</span><span class="o">-&gt;</span><span class="n">instance_size</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">instance_size</span><span class="p">;</span>

    <span class="n">ti</span><span class="o">-&gt;</span><span class="n">class_init</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">class_init</span><span class="p">;</span>
    <span class="n">ti</span><span class="o">-&gt;</span><span class="n">class_base_init</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">class_base_init</span><span class="p">;</span>
    <span class="n">ti</span><span class="o">-&gt;</span><span class="n">class_finalize</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">class_finalize</span><span class="p">;</span>
    <span class="n">ti</span><span class="o">-&gt;</span><span class="n">class_data</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">class_data</span><span class="p">;</span>

    <span class="n">ti</span><span class="o">-&gt;</span><span class="n">instance_init</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">instance_init</span><span class="p">;</span>
    <span class="n">ti</span><span class="o">-&gt;</span><span class="n">instance_post_init</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">instance_post_init</span><span class="p">;</span>
    <span class="n">ti</span><span class="o">-&gt;</span><span class="n">instance_finalize</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">instance_finalize</span><span class="p">;</span>

    <span class="n">ti</span><span class="o">-&gt;</span><span class="n">abstract</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">abstract</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">interfaces</span> <span class="o">&amp;&amp;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">interfaces</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ti</span><span class="o">-&gt;</span><span class="n">interfaces</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="kr">typename</span> <span class="o">=</span> <span class="n">g_strdup</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">interfaces</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">ti</span><span class="o">-&gt;</span><span class="n">num_interfaces</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">ti</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">TypeImpl</span> <span class="o">*</span><span class="n">type_register_internal</span><span class="p">(</span><span class="k">const</span> <span class="n">TypeInfo</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">TypeImpl</span> <span class="o">*</span><span class="n">ti</span><span class="p">;</span>
    <span class="n">ti</span> <span class="o">=</span> <span class="n">type_new</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

    <span class="n">type_table_add</span><span class="p">(</span><span class="n">ti</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">ti</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">TypeImpl</span> <span class="o">*</span><span class="n">type_register</span><span class="p">(</span><span class="k">const</span> <span class="n">TypeInfo</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">type_register_internal</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">TypeImpl</span> <span class="o">*</span><span class="n">type_register_static</span><span class="p">(</span><span class="k">const</span> <span class="n">TypeInfo</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">type_register</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>module_call_init()函数</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13</pre></td><td class="code"><pre><span class="n">util</span><span class="o">/</span><span class="n">module</span><span class="p">.</span><span class="n">c</span>

<span class="kt">void</span> <span class="n">module_call_init</span><span class="p">(</span><span class="n">module_init_type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ModuleTypeList</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>
    <span class="n">ModuleEntry</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>

    <span class="n">l</span> <span class="o">=</span> <span class="n">find_type</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>

    <span class="n">QTAILQ_FOREACH</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">e</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>TypeInfo数据结构</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></td><td class="code"><pre><span class="n">include</span><span class="o">/</span><span class="n">qom</span><span class="o">/</span><span class="n">object</span><span class="p">.</span><span class="n">h</span>

<span class="k">struct</span> <span class="n">TypeInfo</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>

    <span class="kt">size_t</span> <span class="n">instance_size</span><span class="p">;</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">instance_init</span><span class="p">)(</span><span class="n">Object</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">instance_post_init</span><span class="p">)(</span><span class="n">Object</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">instance_finalize</span><span class="p">)(</span><span class="n">Object</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span>

    <span class="n">bool</span> <span class="n">abstract</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">class_size</span><span class="p">;</span>

    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">class_init</span><span class="p">)(</span><span class="n">ObjectClass</span> <span class="o">*</span><span class="n">klass</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">class_base_init</span><span class="p">)(</span><span class="n">ObjectClass</span> <span class="o">*</span><span class="n">klass</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">class_finalize</span><span class="p">)(</span><span class="n">ObjectClass</span> <span class="o">*</span><span class="n">klass</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">class_data</span><span class="p">;</span>

    <span class="n">InterfaceInfo</span> <span class="o">*</span><span class="n">interfaces</span><span class="p">;</span>
<span class="p">};</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>TypeImpl数据结构</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre></td><td class="code"><pre><span class="n">qom</span><span class="o">/</span><span class="n">object</span><span class="p">.</span><span class="n">c</span>

<span class="k">struct</span> <span class="n">TypeImpl</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>

    <span class="kt">size_t</span> <span class="n">class_size</span><span class="p">;</span>

    <span class="kt">size_t</span> <span class="n">instance_size</span><span class="p">;</span>

    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">class_init</span><span class="p">)(</span><span class="n">ObjectClass</span> <span class="o">*</span><span class="n">klass</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">class_base_init</span><span class="p">)(</span><span class="n">ObjectClass</span> <span class="o">*</span><span class="n">klass</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">class_finalize</span><span class="p">)(</span><span class="n">ObjectClass</span> <span class="o">*</span><span class="n">klass</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

    <span class="kt">void</span> <span class="o">*</span><span class="n">class_data</span><span class="p">;</span>

    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">instance_init</span><span class="p">)(</span><span class="n">Object</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">instance_post_init</span><span class="p">)(</span><span class="n">Object</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">instance_finalize</span><span class="p">)(</span><span class="n">Object</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span>

    <span class="n">bool</span> <span class="n">abstract</span><span class="p">;</span>

    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
    <span class="n">TypeImpl</span> <span class="o">*</span><span class="n">parent_type</span><span class="p">;</span>

    <span class="n">ObjectClass</span> <span class="o">*</span><span class="n">class</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">num_interfaces</span><span class="p">;</span>
    <span class="n">InterfaceImpl</span> <span class="n">interfaces</span><span class="p">[</span><span class="n">MAX_INTERFACES</span><span class="p">];</span>
<span class="p">};</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="type_register_static源码分析">type_register_static()源码分析</h3>
<p>从前面的分析，可以得知：</p>
<ul>
  <li>每个type_init()都会生成一个对应的构造函数</li>
  <li>每个构造函数都由OS在main之前调用</li>
  <li>每个构造函数生成一个节点，放入func和type，然后把节点插入到type对应的队列中</li>
</ul>

<p>而这每个节点中func(即type_init()的参数)是怎么调用的呢？</p>

<p>原来在main()中，会先后初始化TRACE/QOM/OPTS：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre><span class="n">vl</span><span class="p">.</span><span class="n">c</span>

<span class="n">module_call_init</span><span class="p">(</span><span class="n">MODULE_INIT_TRACE</span><span class="p">);</span>

<span class="n">module_call_init</span><span class="p">(</span><span class="n">MODULE_INIT_QOM</span><span class="p">);</span>

<span class="n">module_call_init</span><span class="p">(</span><span class="n">MODULE_INIT_OPTS</span><span class="p">);</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>以这个QOM初始化为例，module_call_init()遍历QOM队列中的每个节点，并执行节点中的func函数。
而每个Type注册函数调用type_register_static()来完成TypeInfo到TypeImpl的转换：
 <img src="/pictures/qemu-module-04.svg" alt="函数调用流" /></p>

<p>而已经有了TypeInfo，为什么还要用TypeImpl，可能是为了速度(各个TypeInfo单独存在，
而TypeImpl是采用的Hash组织起来的)：
<img src="/pictures/qemu-module-05.svg" alt="数据结构" /></p>

<h3 id="typeimpl的操作">TypeImpl的操作</h3>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></td><td class="code"><pre><span class="n">qom</span><span class="o">/</span><span class="n">object</span><span class="p">.</span><span class="n">c</span>

<span class="k">static</span> <span class="n">GHashTable</span> <span class="o">*</span><span class="n">type_table_get</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">GHashTable</span> <span class="o">*</span><span class="n">type_table</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">type_table</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">type_table</span> <span class="o">=</span> <span class="n">g_hash_table_new</span><span class="p">(</span><span class="n">g_str_hash</span><span class="p">,</span> <span class="n">g_str_equal</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">type_table</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">enumerating_types</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">type_table_add</span><span class="p">(</span><span class="n">TypeImpl</span> <span class="o">*</span><span class="n">ti</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">enumerating_types</span><span class="p">);</span>
    <span class="n">g_hash_table_insert</span><span class="p">(</span><span class="n">type_table_get</span><span class="p">(),</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ti</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">TypeImpl</span> <span class="o">*</span><span class="nf">type_table_lookup</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">g_hash_table_lookup</span><span class="p">(</span><span class="n">type_table_get</span><span class="p">(),</span> <span class="n">name</span><span class="p">);</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>即TypeImpl采用的关键字为对象名字与对象之间建立Hash关系。</p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
