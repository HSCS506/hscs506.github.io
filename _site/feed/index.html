<?xml version="1.0" encoding="utf-8"?>
  <rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>maow</title>
    <link href="/feed/" rel="self" />
    <link href="http://hscs506.github.io/" />
    <lastBuildDate>2018-05-10T00:04:49+08:00</lastBuildDate>
    <webMaster>maow.cd@foxmail.com</webMaster>
    
    <item>
      <title>QEMU Develop Manual</title>
      <link href="/2018/04/qemu-develop-manual/"/>
      <pubDate>2018-04-26T00:00:00+08:00</pubDate>
      <author>maow</author>
      <guid>/2018/04/qemu-develop-manual</guid>
      <content:encoded><![CDATA[<p>本文主要分析QEMU的建模API</p>

<h1 id="machine-api">Machine API</h1>

<h2 id="machine-register-api">Machine Register API</h2>

<h3 id="查看默认的machine">查看默认的Machine</h3>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13</pre></td><td class="code"><pre><span class="gp">$ </span>qemu-system-ppc -machine <span class="nb">help
</span>Supported machines are:
40p                  IBM RS/6000 7020 <span class="o">(</span>40p<span class="o">)</span>
bamboo               bamboo
g3beige              Heathrow based PowerMAC <span class="o">(</span>default<span class="o">)</span>
mac99                Mac99 based PowerMAC
mpc8544ds            mpc8544ds
none                 empty machine
ppce500              generic paravirt e500 platform
prep                 PowerPC PREP platform
ref405ep             ref405ep
taihu                taihu
virtex-ml507         Xilinx Virtex ML507 reference design<span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="在makefile中添加配置选项">在Makefile中添加配置选项</h3>
<p>在PowerPC的默认配置选项中添加：</p>

<figure class="highlight"><pre><code class="language-make" data-lang="make"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre><span class="err">defaults-configs/ppc-softmmu.mak</span>

<span class="nv">CONFIG_VMC</span><span class="o">=</span><span class="err">y</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>在具体编译对象中添加：</p>

<figure class="highlight"><pre><code class="language-make" data-lang="make"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre><span class="err">hw/ppc/Makefile.objs</span>

<span class="c"># VMC
</span><span class="err">obj-$(CONFIG_VMC)</span> <span class="err">+=</span> <span class="err">vmc.o</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="添加machine源码">添加Machine源码</h3>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38</pre></td><td class="code"><pre><span class="n">hw</span><span class="o">/</span><span class="n">ppc</span><span class="o">/</span><span class="n">vmc</span><span class="p">.</span><span class="n">c</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">ppc_vmc_init</span><span class="p">(</span><span class="n">MachineState</span> <span class="o">*</span><span class="n">machine</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">...</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">heathrow_kvm_type</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* Always force PR KVM */</span>
    <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">vmc_class_init</span><span class="p">(</span><span class="n">ObjectClass</span> <span class="o">*</span><span class="n">oc</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">MachineClass</span> <span class="o">*</span><span class="n">mc</span> <span class="o">=</span> <span class="n">MACHINE_CLASS</span><span class="p">(</span><span class="n">oc</span><span class="p">);</span>

    <span class="n">mc</span><span class="o">-&gt;</span><span class="n">desc</span>               <span class="o">=</span> <span class="s">"VMC PowerPC 755"</span><span class="p">;</span>
    <span class="n">mc</span><span class="o">-&gt;</span><span class="n">init</span>               <span class="o">=</span> <span class="n">ppc_vmc_init</span><span class="p">;</span>
    <span class="n">mc</span><span class="o">-&gt;</span><span class="n">block_default_type</span> <span class="o">=</span> <span class="n">IF_PFLASH</span><span class="p">;</span>
    <span class="n">mc</span><span class="o">-&gt;</span><span class="n">max_cpus</span>           <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">mc</span><span class="o">-&gt;</span><span class="n">default_boot_order</span> <span class="o">=</span> <span class="s">"cd"</span><span class="p">;</span>
    <span class="n">mc</span><span class="o">-&gt;</span><span class="n">kvm_type</span>           <span class="o">=</span> <span class="n">heathrow_kvm_type</span><span class="p">;</span>
    <span class="n">mc</span><span class="o">-&gt;</span><span class="n">default_cpu_type</span>   <span class="o">=</span> <span class="n">POWERPC_CPU_TYPE_NAME</span><span class="p">(</span><span class="s">"755_v2.8"</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">TypeInfo</span> <span class="n">ppc_vmc_machine_info</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">name</span>          <span class="o">=</span> <span class="n">MACHINE_TYPE_NAME</span><span class="p">(</span><span class="s">"VMC"</span><span class="p">),</span>
    <span class="p">.</span><span class="n">parent</span>        <span class="o">=</span> <span class="n">TYPE_MACHINE</span><span class="p">,</span>
    <span class="p">.</span><span class="n">class_init</span>    <span class="o">=</span> <span class="n">vmc_class_init</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ppc_vmc_register_types</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">type_register_static</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ppc_vmc_machine_info</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">type_init</span><span class="p">(</span><span class="n">ppc_vmc_register_types</span><span class="p">);</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>添加了这些代码，编译后在查看Machine</p>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14</pre></td><td class="code"><pre><span class="gp">$ </span>qemu-system-ppc -machine <span class="nb">help
</span>Supported machines are:
40p                  IBM RS/6000 7020 <span class="o">(</span>40p<span class="o">)</span>
VMC                  VMC PowerPC 755
bamboo               bamboo
g3beige              Heathrow based PowerMAC <span class="o">(</span>default<span class="o">)</span>
mac99                Mac99 based PowerMAC
mpc8544ds            mpc8544ds
none                 empty machine
ppce500              generic paravirt e500 platform
prep                 PowerPC PREP platform
ref405ep             ref405ep
taihu                taihu
virtex-ml507         Xilinx Virtex ML507 reference design<span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>MachineClass结构体定义：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58</pre></td><td class="code"><pre><span class="n">include</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">boards</span><span class="p">.</span><span class="n">h</span>

<span class="k">struct</span> <span class="n">MachineClass</span> <span class="p">{</span>
    <span class="cm">/*&lt; private &gt;*/</span>
    <span class="n">ObjectClass</span> <span class="n">parent_class</span><span class="p">;</span>
    <span class="cm">/*&lt; public &gt;*/</span>

    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">family</span><span class="p">;</span> <span class="cm">/* NULL iff @name identifies a standalone machtype */</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">alias</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>

    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">init</span><span class="p">)(</span><span class="n">MachineState</span> <span class="o">*</span><span class="n">state</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">reset</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">hot_add_cpu</span><span class="p">)(</span><span class="k">const</span> <span class="kt">int64_t</span> <span class="n">id</span><span class="p">,</span> <span class="n">Error</span> <span class="o">**</span><span class="n">errp</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">kvm_type</span><span class="p">)(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>

    <span class="n">BlockInterfaceType</span> <span class="n">block_default_type</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">units_per_default_bus</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">max_cpus</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">min_cpus</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">default_cpus</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">no_serial</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">no_parallel</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">use_virtcon</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">use_sclp</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">no_floppy</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">no_cdrom</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">no_sdcard</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">has_dynamic_sysbus</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">pci_allow_0_address</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">legacy_fw_cfg_order</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">is_default</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">default_machine_opts</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">default_boot_order</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">default_display</span><span class="p">;</span>
    <span class="n">GArray</span> <span class="o">*</span><span class="n">compat_props</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hw_version</span><span class="p">;</span>
    <span class="n">ram_addr_t</span> <span class="n">default_ram_size</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">default_cpu_type</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">option_rom_has_mr</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">rom_file_has_mr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">minimum_page_bits</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">has_hotpluggable_cpus</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">ignore_memory_transaction_failures</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">numa_mem_align_shift</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">valid_cpu_types</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">auto_enable_numa_with_memhp</span><span class="p">;</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">numa_auto_assign_ram</span><span class="p">)(</span><span class="n">MachineClass</span> <span class="o">*</span><span class="n">mc</span><span class="p">,</span> <span class="n">NodeInfo</span> <span class="o">*</span><span class="n">nodes</span><span class="p">,</span>
                                 <span class="kt">int</span> <span class="n">nb_nodes</span><span class="p">,</span> <span class="n">ram_addr_t</span> <span class="n">size</span><span class="p">);</span>

    <span class="n">HotplugHandler</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">get_hotplug_handler</span><span class="p">)(</span><span class="n">MachineState</span> <span class="o">*</span><span class="n">machine</span><span class="p">,</span>
                                           <span class="n">DeviceState</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
    <span class="n">CpuInstanceProperties</span> <span class="p">(</span><span class="o">*</span><span class="n">cpu_index_to_instance_props</span><span class="p">)(</span><span class="n">MachineState</span> <span class="o">*</span><span class="n">machine</span><span class="p">,</span>
                                                         <span class="kt">unsigned</span> <span class="n">cpu_index</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">CPUArchIdList</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">possible_cpu_arch_ids</span><span class="p">)(</span><span class="n">MachineState</span> <span class="o">*</span><span class="n">machine</span><span class="p">);</span>
    <span class="kt">int64_t</span> <span class="p">(</span><span class="o">*</span><span class="n">get_default_cpu_node_id</span><span class="p">)(</span><span class="k">const</span> <span class="n">MachineState</span> <span class="o">*</span><span class="n">ms</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">);</span>
<span class="p">};</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>block_default_type的类型：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12</pre></td><td class="code"><pre><span class="n">include</span><span class="o">/</span><span class="n">sysemu</span><span class="o">/</span><span class="n">blockdev</span><span class="p">.</span><span class="n">h</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
    <span class="n">IF_DEFAULT</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>            <span class="cm">/* for use with drive_add() only */</span>
    <span class="cm">/*
     * IF_NONE must be zero, because we want MachineClass member
     * block_default_type to default-initialize to IF_NONE
     */</span>
    <span class="n">IF_NONE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">IF_IDE</span><span class="p">,</span> <span class="n">IF_SCSI</span><span class="p">,</span> <span class="n">IF_FLOPPY</span><span class="p">,</span> <span class="n">IF_PFLASH</span><span class="p">,</span> <span class="n">IF_MTD</span><span class="p">,</span> <span class="n">IF_SD</span><span class="p">,</span> <span class="n">IF_VIRTIO</span><span class="p">,</span> <span class="n">IF_XEN</span><span class="p">,</span>
    <span class="n">IF_COUNT</span>
<span class="p">}</span> <span class="n">BlockInterfaceType</span><span class="p">;</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="查看默认的cpu">查看默认的CPU</h3>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre><span class="gp">$ </span>qemu-system-ppc -cpu <span class="nb">help</span>
...
PowerPC 755_v2.8         PVR 00083208
PowerPC 755              <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>755_v2.8<span class="o">)</span>
...
PowerPC e500             <span class="o">(</span><span class="nb">alias </span><span class="k">for </span>e500v2_v22<span class="o">)</span>
...<span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h1 id="内存">内存</h1>

<h2 id="memory">Memory</h2>
<p>使用Gnome的GLib：</p>
<blockquote>
  <p>GLib provides the core application building blocks for libraries and
applications written in C. It provides the core object system used in GNOME,
the main loop implementation, and a large set of utility functions for
strings and common data structures.</p>
</blockquote>

<h2 id="memory-allocation">Memory Allocation</h2>
<p><a href="https://developer.gnome.org/glib/unstable/glib-Memory
-Allocation.html">Memory Allocation</a> — general memory-handling</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36</pre></td><td class="code"><pre><span class="cp">#include &lt;glib.h&gt;
</span>
<span class="n">These</span> <span class="n">functions</span> <span class="n">provide</span> <span class="n">support</span> <span class="k">for</span> <span class="n">allocating</span> <span class="n">and</span> <span class="n">freeing</span> <span class="n">memory</span><span class="p">.</span>

<span class="n">If</span> <span class="n">any</span> <span class="n">call</span> <span class="n">to</span> <span class="n">allocate</span> <span class="n">memory</span> <span class="n">using</span> <span class="n">functions</span> <span class="n">g_new</span><span class="p">(),</span> <span class="n">g_new0</span><span class="p">(),</span> <span class="n">g_renew</span><span class="p">(),</span>
<span class="n">g_malloc</span><span class="p">(),</span> <span class="n">g_malloc0</span><span class="p">(),</span> <span class="n">g_malloc0_n</span><span class="p">(),</span> <span class="n">g_realloc</span><span class="p">(),</span> <span class="n">and</span> <span class="n">g_realloc_n</span><span class="p">()</span> <span class="n">fails</span><span class="p">,</span>
<span class="n">the</span> <span class="n">application</span> <span class="n">is</span> <span class="n">terminated</span><span class="p">.</span> <span class="n">This</span> <span class="n">also</span> <span class="n">means</span> <span class="n">that</span> <span class="n">there</span> <span class="n">is</span> <span class="n">no</span> <span class="n">need</span> <span class="n">to</span> <span class="n">check</span>
<span class="k">if</span> <span class="n">the</span> <span class="n">call</span> <span class="n">succeeded</span><span class="p">.</span> <span class="n">On</span> <span class="n">the</span> <span class="n">other</span> <span class="n">hand</span><span class="p">,</span> <span class="n">g_try_</span><span class="p">...()</span> <span class="n">family</span> <span class="n">of</span> <span class="n">functions</span>
<span class="n">returns</span> <span class="nb">NULL</span> <span class="n">on</span> <span class="n">failure</span> <span class="n">that</span> <span class="n">can</span> <span class="n">be</span> <span class="n">used</span> <span class="n">as</span> <span class="n">a</span> <span class="n">check</span> <span class="k">for</span> <span class="n">unsuccessful</span> <span class="n">memory</span>
<span class="n">allocation</span><span class="p">.</span> <span class="n">The</span> <span class="n">application</span> <span class="n">is</span> <span class="n">not</span> <span class="n">terminated</span> <span class="n">in</span> <span class="n">this</span> <span class="k">case</span><span class="p">.</span>

<span class="n">It</span><span class="err">'</span><span class="n">s</span> <span class="n">important</span> <span class="n">to</span> <span class="n">match</span> <span class="n">g_malloc</span><span class="p">()</span> <span class="p">(</span><span class="n">and</span> <span class="n">wrappers</span> <span class="n">such</span> <span class="n">as</span> <span class="n">g_new</span><span class="p">())</span> <span class="n">with</span>
<span class="n">g_free</span><span class="p">(),</span> <span class="n">g_slice_alloc</span><span class="p">()</span> <span class="p">(</span><span class="n">and</span> <span class="n">wrappers</span> <span class="n">such</span> <span class="n">as</span> <span class="n">g_slice_new</span><span class="p">())</span> <span class="n">with</span>
<span class="n">g_slice_free</span><span class="p">(),</span> <span class="n">plain</span> <span class="n">malloc</span><span class="p">()</span> <span class="n">with</span> <span class="n">free</span><span class="p">(),</span> <span class="n">and</span> <span class="p">(</span><span class="k">if</span> <span class="n">you</span><span class="err">'</span><span class="n">re</span> <span class="n">using</span> <span class="n">C</span><span class="o">++</span><span class="p">)</span>
<span class="n">new</span> <span class="n">with</span> <span class="n">delete</span> <span class="n">and</span> <span class="n">new</span><span class="p">[]</span> <span class="n">with</span> <span class="n">delete</span><span class="p">[].</span> <span class="n">Otherwise</span> <span class="n">bad</span> <span class="n">things</span> <span class="n">can</span> <span class="n">happen</span><span class="p">,</span>
<span class="n">since</span> <span class="n">these</span> <span class="n">allocators</span> <span class="n">may</span> <span class="n">use</span> <span class="n">different</span> <span class="n">memory</span> <span class="n">pools</span> <span class="p">(</span><span class="n">and</span> <span class="n">new</span><span class="o">/</span><span class="n">delete</span> <span class="n">call</span>
<span class="n">constructors</span> <span class="n">and</span> <span class="n">destructors</span><span class="p">).</span>

<span class="n">functions</span>

<span class="cp">#define             g_new(struct_type, n_structs)
</span>
<span class="n">Allocates</span> <span class="n">n_structs</span> <span class="n">elements</span> <span class="n">of</span> <span class="n">type</span> <span class="n">struct_type</span> <span class="p">.</span> <span class="n">The</span> <span class="n">returned</span> <span class="n">pointer</span> <span class="n">is</span>
<span class="n">cast</span> <span class="n">to</span> <span class="n">a</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">the</span> <span class="n">given</span> <span class="n">type</span><span class="p">.</span> <span class="n">If</span> <span class="n">n_structs</span> <span class="n">is</span> <span class="mi">0</span> <span class="n">it</span> <span class="n">returns</span> <span class="nb">NULL</span><span class="p">.</span> <span class="n">Care</span>
<span class="n">is</span> <span class="n">taken</span> <span class="n">to</span> <span class="n">avoid</span> <span class="n">overflow</span> <span class="n">when</span> <span class="n">calculating</span> <span class="n">the</span> <span class="n">size</span> <span class="n">of</span> <span class="n">the</span> <span class="n">allocated</span> <span class="n">block</span><span class="p">.</span>

<span class="n">Since</span> <span class="n">the</span> <span class="n">returned</span> <span class="n">pointer</span> <span class="n">is</span> <span class="n">already</span> <span class="n">casted</span> <span class="n">to</span> <span class="n">the</span> <span class="n">right</span> <span class="n">type</span><span class="p">,</span> <span class="n">it</span> <span class="n">is</span>
<span class="n">normally</span> <span class="n">unnecessary</span> <span class="n">to</span> <span class="n">cast</span> <span class="n">it</span> <span class="n">explicitly</span><span class="p">,</span> <span class="n">and</span> <span class="n">doing</span> <span class="n">so</span> <span class="n">might</span> <span class="n">hide</span>
<span class="n">memory</span> <span class="n">allocation</span> <span class="n">errors</span><span class="p">.</span>

<span class="n">Parameters</span>
    <span class="n">struct_type</span> <span class="n">the</span> <span class="n">type</span> <span class="n">of</span> <span class="n">the</span> <span class="n">elements</span> <span class="n">to</span> <span class="n">allocate</span>
    <span class="n">n_structs</span>   <span class="n">the</span> <span class="n">number</span> <span class="n">of</span> <span class="n">elements</span> <span class="n">to</span> <span class="n">allocate</span>

<span class="n">Returns</span>
    <span class="n">a</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">the</span> <span class="n">allocated</span> <span class="n">memory</span><span class="p">,</span> <span class="n">cast</span> <span class="n">to</span> <span class="n">a</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">struct_type</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h2 id="memoryregion">MemoryRegion</h2>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42</pre></td><td class="code"><pre><span class="n">include</span><span class="o">/</span><span class="n">exec</span><span class="o">/</span><span class="n">memory</span><span class="p">.</span><span class="n">h</span>

<span class="k">struct</span> <span class="n">MemoryRegion</span> <span class="p">{</span>
    <span class="n">Object</span> <span class="n">parent_obj</span><span class="p">;</span>

    <span class="cm">/* All fields are private - violators will be prosecuted */</span>

    <span class="cm">/* The following fields should fit in a cache line */</span>
    <span class="n">bool</span> <span class="n">romd_mode</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">ram</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">subpage</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">readonly</span><span class="p">;</span> <span class="cm">/* For RAM regions */</span>
    <span class="n">bool</span> <span class="n">rom_device</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">flush_coalesced_mmio</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">global_locking</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">dirty_log_mask</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">is_iommu</span><span class="p">;</span>
    <span class="n">RAMBlock</span> <span class="o">*</span><span class="n">ram_block</span><span class="p">;</span>
    <span class="n">Object</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">MemoryRegionOps</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">opaque</span><span class="p">;</span>
    <span class="n">MemoryRegion</span> <span class="o">*</span><span class="n">container</span><span class="p">;</span>
    <span class="n">Int128</span> <span class="n">size</span><span class="p">;</span>
    <span class="n">hwaddr</span> <span class="n">addr</span><span class="p">;</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destructor</span><span class="p">)(</span><span class="n">MemoryRegion</span> <span class="o">*</span><span class="n">mr</span><span class="p">);</span>
    <span class="kt">uint64_t</span> <span class="n">align</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">terminates</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">ram_device</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">enabled</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">warning_printed</span><span class="p">;</span> <span class="cm">/* For reservations */</span>
    <span class="kt">uint8_t</span> <span class="n">vga_logging_count</span><span class="p">;</span>
    <span class="n">MemoryRegion</span> <span class="o">*</span><span class="n">alias</span><span class="p">;</span>
    <span class="n">hwaddr</span> <span class="n">alias_offset</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">priority</span><span class="p">;</span>
    <span class="n">QTAILQ_HEAD</span><span class="p">(</span><span class="n">subregions</span><span class="p">,</span> <span class="n">MemoryRegion</span><span class="p">)</span> <span class="n">subregions</span><span class="p">;</span>
    <span class="n">QTAILQ_ENTRY</span><span class="p">(</span><span class="n">MemoryRegion</span><span class="p">)</span> <span class="n">subregions_link</span><span class="p">;</span>
    <span class="n">QTAILQ_HEAD</span><span class="p">(</span><span class="n">coalesced_ranges</span><span class="p">,</span> <span class="n">CoalescedMemoryRange</span><span class="p">)</span> <span class="n">coalesced</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="n">ioeventfd_nb</span><span class="p">;</span>
    <span class="n">MemoryRegionIoeventfd</span> <span class="o">*</span><span class="n">ioeventfds</span><span class="p">;</span>
<span class="p">};</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h2 id="ramblock">RAMBlock</h2>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29</pre></td><td class="code"><pre><span class="n">include</span><span class="o">/</span><span class="n">exec</span><span class="o">/</span><span class="n">ram_addr</span><span class="p">.</span><span class="n">h</span>

<span class="k">struct</span> <span class="n">RAMBlock</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">rcu</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">MemoryRegion</span> <span class="o">*</span><span class="n">mr</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">host</span><span class="p">;</span>
    <span class="n">ram_addr_t</span> <span class="n">offset</span><span class="p">;</span>
    <span class="n">ram_addr_t</span> <span class="n">used_length</span><span class="p">;</span>
    <span class="n">ram_addr_t</span> <span class="n">max_length</span><span class="p">;</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">resized</span><span class="p">)(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">length</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">host</span><span class="p">);</span>
    <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">;</span>
    <span class="cm">/* Protected by iothread lock.  */</span>
    <span class="kt">char</span> <span class="n">idstr</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
    <span class="cm">/* RCU-enabled, writes protected by the ramlist lock */</span>
    <span class="n">QLIST_ENTRY</span><span class="p">(</span><span class="n">RAMBlock</span><span class="p">)</span> <span class="n">next</span><span class="p">;</span>
    <span class="n">QLIST_HEAD</span><span class="p">(,</span> <span class="n">RAMBlockNotifier</span><span class="p">)</span> <span class="n">ramblock_notifiers</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">page_size</span><span class="p">;</span>
    <span class="cm">/* dirty bitmap used during migration */</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">bmap</span><span class="p">;</span>
    <span class="cm">/* bitmap of pages that haven't been sent even once
     * only maintained and used in postcopy at the moment
     * where it's used to send the dirtymap at the start
     * of the postcopy phase
     */</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">unsentmap</span><span class="p">;</span>
    <span class="cm">/* bitmap of already received pages in postcopy */</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">receivedmap</span><span class="p">;</span>
<span class="p">};</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h2 id="get_system_memory">get_system_memory()</h2>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre><span class="n">exec</span><span class="p">.</span><span class="n">c</span>

<span class="n">MemoryRegion</span> <span class="o">*</span><span class="n">get_system_memory</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">system_memory</span><span class="p">;</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h2 id="memory_region_allocate_system_memory">memory_region_allocate_system_memory()</h2>
<p>头文件</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34</pre></td><td class="code"><pre><span class="n">include</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">boards</span><span class="p">.</span><span class="n">h</span>

<span class="cm">/**
 * memory_region_allocate_system_memory - Allocate a board's main memory
 * @mr: the #MemoryRegion to be initialized
 * @owner: the object that tracks the region's reference count
 * @name: name of the memory region
 * @ram_size: size of the region in bytes
 *
 * This function allocates the main memory for a board model, and
 * initializes @mr appropriately. It also arranges for the memory
 * to be migrated (by calling vmstate_register_ram_global()).
 *
 * Memory allocated via this function will be backed with the memory
 * backend the user provided using "-mem-path" or "-numa node,memdev=..."
 * if appropriate; this is typically used to cause host huge pages to be
 * used. This function should therefore be called by a board exactly once,
 * for the primary or largest RAM area it implements.
 *
 * For boards where the major RAM is split into two parts in the memory
 * map, you can deal with this by calling memory_region_allocate_system_memory()
 * once to get a MemoryRegion with enough RAM for both parts, and then
 * creating alias MemoryRegions via memory_region_init_alias() which
 * alias into different parts of the RAM MemoryRegion and can be mapped
 * into the memory map in the appropriate places.
 *
 * Smaller pieces of memory (display RAM, static RAMs, etc) don't need
 * to be backed via the -mem-path memory backend and can simply
 * be created via memory_region_allocate_aux_memory() or
 * memory_region_init_ram().
 */</span>
<span class="kt">void</span> <span class="n">memory_region_allocate_system_memory</span><span class="p">(</span><span class="n">MemoryRegion</span> <span class="o">*</span><span class="n">mr</span><span class="p">,</span> <span class="n">Object</span> <span class="o">*</span><span class="n">owner</span><span class="p">,</span>
                                          <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
                                          <span class="kt">uint64_t</span> <span class="n">ram_size</span><span class="p">);</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>函数体</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68</pre></td><td class="code"><pre><span class="n">numa</span><span class="p">.</span><span class="n">c</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">allocate_system_memory_nonnuma</span><span class="p">(</span><span class="n">MemoryRegion</span> <span class="o">*</span><span class="n">mr</span><span class="p">,</span> <span class="n">Object</span> <span class="o">*</span><span class="n">owner</span><span class="p">,</span>
                                           <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
                                           <span class="kt">uint64_t</span> <span class="n">ram_size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mem_path</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef __linux__
</span>        <span class="n">Error</span> <span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">memory_region_init_ram_from_file</span><span class="p">(</span><span class="n">mr</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">ram_size</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span>
                                         <span class="n">mem_path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">error_report_err</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">mem_prealloc</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="cm">/* Legacy behavior: if allocation failed, fall back to
             * regular RAM allocation.
             */</span>
            <span class="n">memory_region_init_ram_nomigrate</span><span class="p">(</span><span class="n">mr</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">ram_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">error_fatal</span><span class="p">);</span>
        <span class="p">}</span>
<span class="cp">#else
</span>        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"-mem-path not supported on this host</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="cp">#endif
</span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">memory_region_init_ram_nomigrate</span><span class="p">(</span><span class="n">mr</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">ram_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">error_fatal</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">vmstate_register_ram_global</span><span class="p">(</span><span class="n">mr</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">memory_region_allocate_system_memory</span><span class="p">(</span><span class="n">MemoryRegion</span> <span class="o">*</span><span class="n">mr</span><span class="p">,</span> <span class="n">Object</span> <span class="o">*</span><span class="n">owner</span><span class="p">,</span>
                                          <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
                                          <span class="kt">uint64_t</span> <span class="n">ram_size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">nb_numa_nodes</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">have_memdevs</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">allocate_system_memory_nonnuma</span><span class="p">(</span><span class="n">mr</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">ram_size</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">memory_region_init</span><span class="p">(</span><span class="n">mr</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">ram_size</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nb_numa_nodes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">uint64_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">numa_info</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">node_mem</span><span class="p">;</span>
        <span class="n">HostMemoryBackend</span> <span class="o">*</span><span class="n">backend</span> <span class="o">=</span> <span class="n">numa_info</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">node_memdev</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">backend</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">MemoryRegion</span> <span class="o">*</span><span class="n">seg</span> <span class="o">=</span> <span class="n">host_memory_backend_get_memory</span><span class="p">(</span><span class="n">backend</span><span class="p">,</span>
                                                           <span class="o">&amp;</span><span class="n">error_fatal</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">memory_region_is_mapped</span><span class="p">(</span><span class="n">seg</span><span class="p">))</span> <span class="p">{</span>
            <span class="kt">char</span> <span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="n">object_get_canonical_path_component</span><span class="p">(</span><span class="n">OBJECT</span><span class="p">(</span><span class="n">backend</span><span class="p">));</span>
            <span class="n">error_report</span><span class="p">(</span><span class="s">"memory backend %s is used multiple times. Each "</span>
                         <span class="s">"-numa option must use a different memdev value."</span><span class="p">,</span>
                         <span class="n">path</span><span class="p">);</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">host_memory_backend_set_mapped</span><span class="p">(</span><span class="n">backend</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
        <span class="n">memory_region_add_subregion</span><span class="p">(</span><span class="n">mr</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">seg</span><span class="p">);</span>
        <span class="n">vmstate_register_ram_global</span><span class="p">(</span><span class="n">seg</span><span class="p">);</span>
        <span class="n">addr</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15</pre></td><td class="code"><pre><span class="n">memory</span><span class="p">.</span><span class="n">c</span>

<span class="kt">void</span> <span class="n">memory_region_init_ram_nomigrate</span><span class="p">(</span><span class="n">MemoryRegion</span> <span class="o">*</span><span class="n">mr</span><span class="p">,</span>
                                      <span class="n">Object</span> <span class="o">*</span><span class="n">owner</span><span class="p">,</span>
                                      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
                                      <span class="kt">uint64_t</span> <span class="n">size</span><span class="p">,</span>
                                      <span class="n">Error</span> <span class="o">**</span><span class="n">errp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">memory_region_init</span><span class="p">(</span><span class="n">mr</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    <span class="n">mr</span><span class="o">-&gt;</span><span class="n">ram</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">mr</span><span class="o">-&gt;</span><span class="n">terminates</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">mr</span><span class="o">-&gt;</span><span class="n">destructor</span> <span class="o">=</span> <span class="n">memory_region_destructor_ram</span><span class="p">;</span>
    <span class="n">mr</span><span class="o">-&gt;</span><span class="n">ram_block</span> <span class="o">=</span> <span class="n">qemu_ram_alloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">mr</span><span class="p">,</span> <span class="n">errp</span><span class="p">);</span>
    <span class="n">mr</span><span class="o">-&gt;</span><span class="n">dirty_log_mask</span> <span class="o">=</span> <span class="n">tcg_enabled</span><span class="p">()</span> <span class="o">?</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">DIRTY_MEMORY_CODE</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43</pre></td><td class="code"><pre><span class="n">exec</span><span class="p">.</span><span class="n">c</span>

<span class="k">static</span>
<span class="n">RAMBlock</span> <span class="o">*</span><span class="n">qemu_ram_alloc_internal</span><span class="p">(</span><span class="n">ram_addr_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">ram_addr_t</span> <span class="n">max_size</span><span class="p">,</span>
                                  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">resized</span><span class="p">)(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span>
                                                  <span class="kt">uint64_t</span> <span class="n">length</span><span class="p">,</span>
                                                  <span class="kt">void</span> <span class="o">*</span><span class="n">host</span><span class="p">),</span>
                                  <span class="kt">void</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="n">bool</span> <span class="n">resizeable</span><span class="p">,</span>
                                  <span class="n">MemoryRegion</span> <span class="o">*</span><span class="n">mr</span><span class="p">,</span> <span class="n">Error</span> <span class="o">**</span><span class="n">errp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">RAMBlock</span> <span class="o">*</span><span class="n">new_block</span><span class="p">;</span>
    <span class="n">Error</span> <span class="o">*</span><span class="n">local_err</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">size</span> <span class="o">=</span> <span class="n">HOST_PAGE_ALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
    <span class="n">max_size</span> <span class="o">=</span> <span class="n">HOST_PAGE_ALIGN</span><span class="p">(</span><span class="n">max_size</span><span class="p">);</span>
    <span class="n">new_block</span> <span class="o">=</span> <span class="n">g_malloc0</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">new_block</span><span class="p">));</span>
    <span class="n">new_block</span><span class="o">-&gt;</span><span class="n">mr</span> <span class="o">=</span> <span class="n">mr</span><span class="p">;</span>
    <span class="n">new_block</span><span class="o">-&gt;</span><span class="n">resized</span> <span class="o">=</span> <span class="n">resized</span><span class="p">;</span>
    <span class="n">new_block</span><span class="o">-&gt;</span><span class="n">used_length</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
    <span class="n">new_block</span><span class="o">-&gt;</span><span class="n">max_length</span> <span class="o">=</span> <span class="n">max_size</span><span class="p">;</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">max_size</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">);</span>
    <span class="n">new_block</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">new_block</span><span class="o">-&gt;</span><span class="n">page_size</span> <span class="o">=</span> <span class="n">getpagesize</span><span class="p">();</span>
    <span class="n">new_block</span><span class="o">-&gt;</span><span class="n">host</span> <span class="o">=</span> <span class="n">host</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">new_block</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">RAM_PREALLOC</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">resizeable</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">new_block</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">RAM_RESIZEABLE</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">ram_block_add</span><span class="p">(</span><span class="n">new_block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">local_err</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">local_err</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">g_free</span><span class="p">(</span><span class="n">new_block</span><span class="p">);</span>
        <span class="n">error_propagate</span><span class="p">(</span><span class="n">errp</span><span class="p">,</span> <span class="n">local_err</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">new_block</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">RAMBlock</span> <span class="o">*</span><span class="n">qemu_ram_alloc</span><span class="p">(</span><span class="n">ram_addr_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">MemoryRegion</span> <span class="o">*</span><span class="n">mr</span><span class="p">,</span> <span class="n">Error</span> <span class="o">**</span><span class="n">errp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">qemu_ram_alloc_internal</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">mr</span><span class="p">,</span> <span class="n">errp</span><span class="p">);</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>AddressSpace结构体</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19</pre></td><td class="code"><pre><span class="n">include</span><span class="o">/</span><span class="n">exec</span><span class="o">/</span><span class="n">memory</span><span class="p">.</span><span class="n">h</span>

<span class="cm">/**
 * AddressSpace: describes a mapping of addresses to #MemoryRegion objects
 */</span>
<span class="k">struct</span> <span class="n">AddressSpace</span> <span class="p">{</span>
    <span class="cm">/* All fields are private. */</span>
    <span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">rcu</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="n">MemoryRegion</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>

    <span class="cm">/* Accessed via RCU.  */</span>
    <span class="k">struct</span> <span class="n">FlatView</span> <span class="o">*</span><span class="n">current_map</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">ioeventfd_nb</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">MemoryRegionIoeventfd</span> <span class="o">*</span><span class="n">ioeventfds</span><span class="p">;</span>
    <span class="n">QTAILQ_HEAD</span><span class="p">(</span><span class="n">memory_listeners_as</span><span class="p">,</span> <span class="n">MemoryListener</span><span class="p">)</span> <span class="n">listeners</span><span class="p">;</span>
    <span class="n">QTAILQ_ENTRY</span><span class="p">(</span><span class="n">AddressSpace</span><span class="p">)</span> <span class="n">address_spaces_link</span><span class="p">;</span>
<span class="p">};</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15</pre></td><td class="code"><pre><span class="n">memory</span><span class="p">.</span><span class="n">c</span>

<span class="kt">void</span> <span class="n">address_space_init</span><span class="p">(</span><span class="n">AddressSpace</span> <span class="o">*</span><span class="n">as</span><span class="p">,</span> <span class="n">MemoryRegion</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">memory_region_ref</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
    <span class="n">as</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
    <span class="n">as</span><span class="o">-&gt;</span><span class="n">current_map</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">as</span><span class="o">-&gt;</span><span class="n">ioeventfd_nb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">as</span><span class="o">-&gt;</span><span class="n">ioeventfds</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">QTAILQ_INIT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">listeners</span><span class="p">);</span>
    <span class="n">QTAILQ_INSERT_TAIL</span><span class="p">(</span><span class="o">&amp;</span><span class="n">address_spaces</span><span class="p">,</span> <span class="n">as</span><span class="p">,</span> <span class="n">address_spaces_link</span><span class="p">);</span>
    <span class="n">as</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">g_strdup</span><span class="p">(</span><span class="n">name</span> <span class="o">?</span> <span class="n">name</span> <span class="o">:</span> <span class="s">"anonymous"</span><span class="p">);</span>
    <span class="n">address_space_update_topology</span><span class="p">(</span><span class="n">as</span><span class="p">);</span>
    <span class="n">address_space_update_ioeventfds</span><span class="p">(</span><span class="n">as</span><span class="p">);</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre><span class="n">memory</span><span class="p">.</span><span class="n">c</span>

<span class="k">static</span> <span class="n">QTAILQ_HEAD</span><span class="p">(</span><span class="n">memory_listeners</span><span class="p">,</span> <span class="n">MemoryListener</span><span class="p">)</span> <span class="n">memory_listeners</span>
    <span class="o">=</span> <span class="n">QTAILQ_HEAD_INITIALIZER</span><span class="p">(</span><span class="n">memory_listeners</span><span class="p">);</span>

<span class="k">static</span> <span class="n">QTAILQ_HEAD</span><span class="p">(,</span> <span class="n">AddressSpace</span><span class="p">)</span> <span class="n">address_spaces</span>
    <span class="o">=</span> <span class="n">QTAILQ_HEAD_INITIALIZER</span><span class="p">(</span><span class="n">address_spaces</span><span class="p">);</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

]]></content:encoded>
    </item>
    
    <item>
      <title>QEMU Configure</title>
      <link href="/2018/04/qemu-configure/"/>
      <pubDate>2018-04-26T00:00:00+08:00</pubDate>
      <author>maow</author>
      <guid>/2018/04/qemu-configure</guid>
      <content:encoded><![CDATA[<p>本文主要分析QEMU的Configure</p>

<h1 id="fdt">FDT</h1>
<p>FDT (Flat device tree)，可以参考 htttp://devicetree.org/Device_Tree_Usage，
https://blog.csdn.net/cosmoslhf/article/details/49364577，
http://www.wowotech.net/linux_kenrel/why-dt.html</p>

<h1 id="capstone">capstone</h1>
<p>Capstone is a disassembly framework with the target of becoming the ultimate
disasm engine for binary analysis and reversing in the security community.</p>

<p>Capstone：用于二进制分析和反转的反汇编框架，支持多种语言的许多架构和绑定。
https://github.com/aquynh/capstone</p>

<h1 id="sparse">sparse</h1>

<h1 id="gnutls">gnutls</h1>
<p>GNUTLS cryptography support</p>

<h1 id="nettle">nettle</h1>
<p>nettle cryptography support</p>

<h1 id="curses">curses</h1>
<p>curses UI</p>

<h1 id="smpnumampp">SMP/NUMA/MPP</h1>
<p><a href="http://www.cnblogs.com/yubo/archive/2010/04/
23/1718810.html">SMP、NUMA、MPP体系结构介绍</a></p>

<p>SMP, Symmetric Multi-Processor，对称多处理器结构：对称多处理系统内有许多紧耦合
多处理器，在这样的系统中，所有的CPU共享全部资源，如总线，内存和I/O系统等，操作系统或
管理数据库的复本只有一个，这种系统有一个最大的特点就是共享所有资源。多个CPU之间没有区别，
平等地访问内存、外设、一个操作系统。操作系统管理着一个队列，每个处理器依次处理队列中的
进程。如果两个处理器同时请求访问一个资源（例如同一段内存地址），由硬件、软件的锁机制去
解决资源争用问题。</p>

<p><img src="/pictures/SMP.svg" alt="SMP" /></p>

<p>所谓对称多处理器结构，是指服务器中多个 CPU 对称工作，无主次或从属关系。各 CPU 共享
相同的物理内存，每个 CPU 访问内存中的任何地址所需时间是相同的，因此 SMP 也被称为
一致存储器访问结构 (UMA ： Uniform Memory Access) 。对 SMP 服务器进行扩展的方式
包括增加内存、使用更快的 CPU 、增加 CPU 、扩充 I/O( 槽口数与总线数 ) 以及添加更多的
外部设备 ( 通常是磁盘存储 ) 。</p>

<p>SMP 服务器的主要特征是共享，系统中所有资源 (CPU 、内存、 I/O 等 ) 都是共享的。也正是
由于这种特征，导致了 SMP 服务器的主要问题，那就是它的扩展能力非常有限。对于 SMP 服务器
而言，每一个共享的环节都可能造成 SMP 服务器扩展时的瓶颈，而最受限制的则是内存。由于
每个 CPU 必须通过相同的内存总线访问相同的内存资源，因此随着 CPU 数量的增加，内存访问冲突
将迅速增加，最终会造成 CPU 资源的浪费，使 CPU 性能的有效性大大降低。实验证明，
SMP 服务器 CPU 利用率最好的情况是 2 至 4 个 CPU 。</p>

<p>NUMA, Non-Uniform Memory Access，非一致存储访问结构：由于 SMP 在扩展能力上的限制，
人们开始探究如何进行有效地扩展从而构建大型系统的技术， NUMA 就是这种努力下的结果之一。
利用 NUMA 技术，可以把几十个 CPU( 甚至上百个 CPU) 组合在一个服务器内。</p>

<p>NUMA 服务器的基本特征是具有多个 CPU 模块，每个 CPU 模块由多个 CPU( 如 4 个 ) 组成，
并且具有独立的本地内存、 I/O 槽口等。由于其节点之间可以通过互联模块 ( 如称为
Crossbar Switch) 进行连接和信息交互，因此每个 CPU 可以访问整个系统的内存 (
这是 NUMA 系统与 MPP 系统的重要差别 ) 。显然，访问本地内存的速度将远远高于
访问远地内存 ( 系统内其它节点的内存 ) 的速度，这也是非一致存储访问 NUMA 的由来。
由于这个特点，为了更好地发挥系统性能，开发应用程序时需要尽量减少不同 CPU 模块之间的
信息交互。</p>

<p>利用 NUMA 技术，可以较好地解决原来 SMP 系统的扩展问题，在一个物理服务器内可以支持
上百个 CPU 。比较典型的 NUMA 服务器的例子包括 HP 的 Superdome 、 SUN15K 、
IBMp690 等。</p>

<p>但 NUMA 技术同样有一定缺陷，由于访问远地内存的延时远远超过本地内存，因此当 CPU
数量增加时，系统性能无法线性增加。如 HP 公司发布 Superdome 服务器时，曾公布了它
与 HP 其它 UNIX 服务器的相对性能值，结果发现， 64 路 CPU 的 Superdome (NUMA 结构 )
的相对性能值是 20 ，而 8 路 N4000( 共享的 SMP 结构 ) 的相对性能值是 6.3 。从这个结果
可以看到， 8 倍数量的 CPU 换来的只是 3 倍性能的提升。</p>

<p>MPP, Massive Parallel Processing，海量并行处理结构：和 NUMA 不同， MPP 提供了另外
一种进行系统扩展的方式，它由多个 SMP 服务器通过一定的节点互联网络进行连接，协同工作，
完成相同的任务，从用户的角度来看是一个服务器系统。其基本特征是由多个 SMP 服务器 (
每个 SMP 服务器称节点 ) 通过节点互联网络连接而成，每个节点只访问自己的本地资源 (
内存、存储等 ) ，是一种完全无共享 (Share Nothing) 结构，因而扩展能力最好，理论上
其扩展无限制，目前的技术可实现 512 个节点互联，数千个 CPU 。目前业界对节点互联网络
暂无标准，如 NCR 的 Bynet ， IBM 的 SPSwitch ，它们都采用了不同的内部实现机制。
但节点互联网仅供 MPP 服务器内部使用，对用户而言是透明的。</p>

<p>在 MPP 系统中，每个 SMP 节点也可以运行自己的操作系统、数据库等。但和 NUMA 不同的是，
它不存在异地内存访问的问题。换言之，每个节点内的 CPU 不能访问另一个节点的内存。节点
之间的信息交互是通过节点互联网络实现的，这个过程一般称为数据重分配
(Data Redistribution) 。</p>

<p>但是 MPP 服务器需要一种复杂的机制来调度和平衡各个节点的负载和并行处理过程。目前一些
基于 MPP 技术的服务器往往通过系统级软件 ( 如数据库 ) 来屏蔽这种复杂性。举例来说，
NCR 的 Teradata 就是基于 MPP 技术的一个关系数据库软件，基于此数据库来开发应用时，
不管后台服务器由多少个节点组成，开发人员所面对的都是同一个数据库系统，而不需要考虑
如何调度其中某几个节点的负载。</p>

<p>MPP (Massively Parallel Processing)，大规模并行处理系统，这样的系统是由许多
松耦合的处理单元组成的，要注意的是这里指的是处理单元而不是处理器。每个单元内的CPU
都有自己私有的资源，如总线，内存，硬盘等。在每个单元内都有操作系统和管理数据库的
实例复本。这种结构最大的特点在于不共享资源。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>QEMU Module Infrastructure</title>
      <link href="/2018/04/qemu-module/"/>
      <pubDate>2018-04-18T00:00:00+08:00</pubDate>
      <author>maow</author>
      <guid>/2018/04/qemu-module</guid>
      <content:encoded><![CDATA[<p>本文主要分析QEMU的Module框架机制</p>

<h1 id="qemu-module-infrastructure">QEMU Module Infrastructure</h1>
<p>相关的Maintainer是IBM的Anthony Liguori (aliguori@us.ibm.com)。</p>

<h2 id="module初始化">Module初始化</h2>

<h3 id="源码">源码</h3>
<p>定义了4种Module: BLOCK,OPTS,QOM,TRACE，其定义如下:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9</pre></td><td class="code"><pre><span class="n">include</span><span class="o">/</span><span class="n">qemu</span><span class="o">/</span><span class="n">module</span><span class="p">.</span><span class="n">h</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
    <span class="n">MODULE_INIT_BLOCK</span><span class="p">,</span>
    <span class="n">MODULE_INIT_OPTS</span><span class="p">,</span>
    <span class="n">MODULE_INIT_QOM</span><span class="p">,</span>
    <span class="n">MODULE_INIT_TRACE</span><span class="p">,</span>
    <span class="n">MODULE_INIT_MAX</span>
<span class="p">}</span> <span class="n">module_init_type</span><span class="p">;</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>针对每种Module的初始化接口，都是C语言的宏:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12</pre></td><td class="code"><pre><span class="n">include</span><span class="o">/</span><span class="n">qemu</span><span class="o">/</span><span class="n">module</span><span class="p">.</span><span class="n">h</span>

<span class="cp">#define block_init(function) module_init(function, MODULE_INIT_BLOCK)
#define opts_init(function) module_init(function, MODULE_INIT_OPTS)
#define type_init(function) module_init(function, MODULE_INIT_QOM)
#define trace_init(function) module_init(function, MODULE_INIT_TRACE)
</span>
<span class="cp">#define module_init(function, type)                                         \
static void __attribute__((constructor)) do_qemu_init_ ## function(void)    \
{                                                                           \
    register_module_init(function, type);                                   \
}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="type_init源码分析">type_init()源码分析</h3>
<p>对应代码，对于每个type_init()都会生成一个对应的构造函数：
<img src="/pictures/qemu-module-01.svg" alt="函数调用流" /></p>

<h3 id="构造函数">构造函数</h3>
<p>这个是利用了GNU Compiler Collection (GCC)的扩展属性，”GCC 7.3 Manual” -&gt;
“6 Extensions to the C Language Family” -&gt; “6.31 Declaring Attributes of
Functions” -&gt; “6.31.1 Common Function Attributes”</p>

<blockquote>
  <p>The <strong>constructor</strong> attribute causes the function to be called automatically
before execution enters main (). Similarly, the destructor attribute causes
the function to be called automatically after main () completes or exit ()
is called. Functions with these attributes are useful for initializing data
that is used implicitly during the execution of the program.</p>
</blockquote>

<h3 id="源码-1">源码</h3>
<p>其register_module_init()函数定义如下:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54</pre></td><td class="code"><pre><span class="n">util</span><span class="o">/</span><span class="n">module</span><span class="p">.</span><span class="n">c</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ModuleEntry</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">init</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
    <span class="n">QTAILQ_ENTRY</span><span class="p">(</span><span class="n">ModuleEntry</span><span class="p">)</span> <span class="n">node</span><span class="p">;</span>
    <span class="n">module_init_type</span> <span class="n">type</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ModuleEntry</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">QTAILQ_HEAD</span><span class="p">(,</span> <span class="n">ModuleEntry</span><span class="p">)</span> <span class="n">ModuleTypeList</span><span class="p">;</span>

<span class="k">static</span> <span class="n">ModuleTypeList</span> <span class="n">init_type_list</span><span class="p">[</span><span class="n">MODULE_INIT_MAX</span><span class="p">];</span>

<span class="k">static</span> <span class="n">ModuleTypeList</span> <span class="n">dso_init_list</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_lists</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">inited</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">inited</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MODULE_INIT_MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">QTAILQ_INIT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_type_list</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="n">QTAILQ_INIT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dso_init_list</span><span class="p">);</span>

    <span class="n">inited</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="n">ModuleTypeList</span> <span class="o">*</span><span class="nf">find_type</span><span class="p">(</span><span class="n">module_init_type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">init_lists</span><span class="p">();</span>

    <span class="k">return</span> <span class="o">&amp;</span><span class="n">init_type_list</span><span class="p">[</span><span class="n">type</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">register_module_init</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">void</span><span class="p">),</span> <span class="n">module_init_type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ModuleEntry</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>
    <span class="n">ModuleTypeList</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>

    <span class="n">e</span> <span class="o">=</span> <span class="n">g_malloc0</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">));</span>
    <span class="n">e</span><span class="o">-&gt;</span><span class="n">init</span> <span class="o">=</span> <span class="n">fn</span><span class="p">;</span>
    <span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>

    <span class="n">l</span> <span class="o">=</span> <span class="n">find_type</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>

    <span class="n">QTAILQ_INSERT_TAIL</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="do_qemu_init_xxx代码分析">do_qemu_init_xxx()代码分析</h3>
<p>每个构造函数都由OS在main之前调用： <img src="/pictures/qemu-module-02.svg" alt="函数调用流" /></p>

<p>每个构造函数生成一个节点，放入func和type，然后把节点插入到type对应的队列中。
数据结构为： <img src="/pictures/qemu-module-03.svg" alt="数据结构" /></p>

<h2 id="module注册">Module注册</h2>

<h3 id="源码-2">源码</h3>
<p>苹果的G3机器注册：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14</pre></td><td class="code"><pre><span class="n">hw</span><span class="o">/</span><span class="n">ppc</span><span class="o">/</span><span class="n">mac_oldworld</span><span class="p">.</span><span class="n">c</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">TypeInfo</span> <span class="n">ppc_heathrow_machine_info</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">name</span>          <span class="o">=</span> <span class="n">MACHINE_TYPE_NAME</span><span class="p">(</span><span class="s">"g3beige"</span><span class="p">),</span>
    <span class="p">.</span><span class="n">parent</span>        <span class="o">=</span> <span class="n">TYPE_MACHINE</span><span class="p">,</span>
    <span class="p">.</span><span class="n">class_init</span>    <span class="o">=</span> <span class="n">heathrow_class_init</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ppc_heathrow_register_types</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">type_register_static</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ppc_heathrow_machine_info</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">type_init</span><span class="p">(</span><span class="n">ppc_heathrow_register_types</span><span class="p">);</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>苹果的G5机器注册：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12</pre></td><td class="code"><pre><span class="k">static</span> <span class="k">const</span> <span class="n">TypeInfo</span> <span class="n">core99_machine_info</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">name</span>          <span class="o">=</span> <span class="n">MACHINE_TYPE_NAME</span><span class="p">(</span><span class="s">"mac99"</span><span class="p">),</span>
    <span class="p">.</span><span class="n">parent</span>        <span class="o">=</span> <span class="n">TYPE_MACHINE</span><span class="p">,</span>
    <span class="p">.</span><span class="n">class_init</span>    <span class="o">=</span> <span class="n">core99_machine_class_init</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mac_machine_register_types</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">type_register_static</span><span class="p">(</span><span class="o">&amp;</span><span class="n">core99_machine_info</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">type_init</span><span class="p">(</span><span class="n">mac_machine_register_types</span><span class="p">)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>PowerPC的硬件参考平台注册：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre><span class="n">hw</span><span class="o">/</span><span class="n">ppc</span><span class="o">/</span><span class="n">prep</span><span class="p">.</span><span class="n">c</span>

<span class="n">DEFINE_MACHINE</span><span class="p">(</span><span class="s">"prep"</span><span class="p">,</span> <span class="n">prep_machine_init</span><span class="p">)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>其中的DEFINE_MACHINE()宏：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18</pre></td><td class="code"><pre><span class="n">include</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">boards</span><span class="p">.</span><span class="n">h</span>

<span class="cp">#define DEFINE_MACHINE(namestr, machine_initfn) \
    static void machine_initfn##_class_init(ObjectClass *oc, void *data) \
    { \
        MachineClass *mc = MACHINE_CLASS(oc); \
        machine_initfn(mc); \
    } \
    static const TypeInfo machine_initfn##_typeinfo = { \
        .name       = MACHINE_TYPE_NAME(namestr), \
        .parent     = TYPE_MACHINE, \
        .class_init = machine_initfn##_class_init, \
    }; \
    static void machine_initfn##_register_types(void) \
    { \
        type_register_static(&amp;machine_initfn##_typeinfo); \
    } \
    type_init(machine_initfn##_register_types)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>而其中的内部注册函数：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58</pre></td><td class="code"><pre><span class="n">qom</span><span class="o">/</span><span class="n">object</span><span class="p">.</span><span class="n">c</span>

<span class="k">static</span> <span class="n">TypeImpl</span> <span class="o">*</span><span class="n">type_new</span><span class="p">(</span><span class="k">const</span> <span class="n">TypeInfo</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">TypeImpl</span> <span class="o">*</span><span class="n">ti</span> <span class="o">=</span> <span class="n">g_malloc0</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ti</span><span class="p">));</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

    <span class="n">g_assert</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">type_table_lookup</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Registering `%s' which already exists</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
        <span class="n">abort</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">ti</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">g_strdup</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
    <span class="n">ti</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">g_strdup</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>

    <span class="n">ti</span><span class="o">-&gt;</span><span class="n">class_size</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">class_size</span><span class="p">;</span>
    <span class="n">ti</span><span class="o">-&gt;</span><span class="n">instance_size</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">instance_size</span><span class="p">;</span>

    <span class="n">ti</span><span class="o">-&gt;</span><span class="n">class_init</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">class_init</span><span class="p">;</span>
    <span class="n">ti</span><span class="o">-&gt;</span><span class="n">class_base_init</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">class_base_init</span><span class="p">;</span>
    <span class="n">ti</span><span class="o">-&gt;</span><span class="n">class_finalize</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">class_finalize</span><span class="p">;</span>
    <span class="n">ti</span><span class="o">-&gt;</span><span class="n">class_data</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">class_data</span><span class="p">;</span>

    <span class="n">ti</span><span class="o">-&gt;</span><span class="n">instance_init</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">instance_init</span><span class="p">;</span>
    <span class="n">ti</span><span class="o">-&gt;</span><span class="n">instance_post_init</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">instance_post_init</span><span class="p">;</span>
    <span class="n">ti</span><span class="o">-&gt;</span><span class="n">instance_finalize</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">instance_finalize</span><span class="p">;</span>

    <span class="n">ti</span><span class="o">-&gt;</span><span class="n">abstract</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">abstract</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">interfaces</span> <span class="o">&amp;&amp;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">interfaces</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ti</span><span class="o">-&gt;</span><span class="n">interfaces</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="kr">typename</span> <span class="o">=</span> <span class="n">g_strdup</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">interfaces</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">ti</span><span class="o">-&gt;</span><span class="n">num_interfaces</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">ti</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">TypeImpl</span> <span class="o">*</span><span class="n">type_register_internal</span><span class="p">(</span><span class="k">const</span> <span class="n">TypeInfo</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">TypeImpl</span> <span class="o">*</span><span class="n">ti</span><span class="p">;</span>
    <span class="n">ti</span> <span class="o">=</span> <span class="n">type_new</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

    <span class="n">type_table_add</span><span class="p">(</span><span class="n">ti</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">ti</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">TypeImpl</span> <span class="o">*</span><span class="n">type_register</span><span class="p">(</span><span class="k">const</span> <span class="n">TypeInfo</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">type_register_internal</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">TypeImpl</span> <span class="o">*</span><span class="n">type_register_static</span><span class="p">(</span><span class="k">const</span> <span class="n">TypeInfo</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">type_register</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>module_call_init()函数</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13</pre></td><td class="code"><pre><span class="n">util</span><span class="o">/</span><span class="n">module</span><span class="p">.</span><span class="n">c</span>

<span class="kt">void</span> <span class="n">module_call_init</span><span class="p">(</span><span class="n">module_init_type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ModuleTypeList</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>
    <span class="n">ModuleEntry</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>

    <span class="n">l</span> <span class="o">=</span> <span class="n">find_type</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>

    <span class="n">QTAILQ_FOREACH</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">e</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>TypeInfo数据结构</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></td><td class="code"><pre><span class="n">include</span><span class="o">/</span><span class="n">qom</span><span class="o">/</span><span class="n">object</span><span class="p">.</span><span class="n">h</span>

<span class="k">struct</span> <span class="n">TypeInfo</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>

    <span class="kt">size_t</span> <span class="n">instance_size</span><span class="p">;</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">instance_init</span><span class="p">)(</span><span class="n">Object</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">instance_post_init</span><span class="p">)(</span><span class="n">Object</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">instance_finalize</span><span class="p">)(</span><span class="n">Object</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span>

    <span class="n">bool</span> <span class="n">abstract</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">class_size</span><span class="p">;</span>

    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">class_init</span><span class="p">)(</span><span class="n">ObjectClass</span> <span class="o">*</span><span class="n">klass</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">class_base_init</span><span class="p">)(</span><span class="n">ObjectClass</span> <span class="o">*</span><span class="n">klass</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">class_finalize</span><span class="p">)(</span><span class="n">ObjectClass</span> <span class="o">*</span><span class="n">klass</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">class_data</span><span class="p">;</span>

    <span class="n">InterfaceInfo</span> <span class="o">*</span><span class="n">interfaces</span><span class="p">;</span>
<span class="p">};</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>TypeImpl数据结构</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre></td><td class="code"><pre><span class="n">qom</span><span class="o">/</span><span class="n">object</span><span class="p">.</span><span class="n">c</span>

<span class="k">struct</span> <span class="n">TypeImpl</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>

    <span class="kt">size_t</span> <span class="n">class_size</span><span class="p">;</span>

    <span class="kt">size_t</span> <span class="n">instance_size</span><span class="p">;</span>

    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">class_init</span><span class="p">)(</span><span class="n">ObjectClass</span> <span class="o">*</span><span class="n">klass</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">class_base_init</span><span class="p">)(</span><span class="n">ObjectClass</span> <span class="o">*</span><span class="n">klass</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">class_finalize</span><span class="p">)(</span><span class="n">ObjectClass</span> <span class="o">*</span><span class="n">klass</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

    <span class="kt">void</span> <span class="o">*</span><span class="n">class_data</span><span class="p">;</span>

    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">instance_init</span><span class="p">)(</span><span class="n">Object</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">instance_post_init</span><span class="p">)(</span><span class="n">Object</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">instance_finalize</span><span class="p">)(</span><span class="n">Object</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span>

    <span class="n">bool</span> <span class="n">abstract</span><span class="p">;</span>

    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
    <span class="n">TypeImpl</span> <span class="o">*</span><span class="n">parent_type</span><span class="p">;</span>

    <span class="n">ObjectClass</span> <span class="o">*</span><span class="n">class</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">num_interfaces</span><span class="p">;</span>
    <span class="n">InterfaceImpl</span> <span class="n">interfaces</span><span class="p">[</span><span class="n">MAX_INTERFACES</span><span class="p">];</span>
<span class="p">};</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="type_register_static源码分析">type_register_static()源码分析</h3>
<p>从前面的分析，可以得知：</p>
<ul>
  <li>每个type_init()都会生成一个对应的构造函数</li>
  <li>每个构造函数都由OS在main之前调用</li>
  <li>每个构造函数生成一个节点，放入func和type，然后把节点插入到type对应的队列中</li>
</ul>

<p>而这每个节点中func(即type_init()的参数)是怎么调用的呢？</p>

<p>原来在main()中，会先后初始化TRACE/QOM/OPTS：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre><span class="n">vl</span><span class="p">.</span><span class="n">c</span>

<span class="n">module_call_init</span><span class="p">(</span><span class="n">MODULE_INIT_TRACE</span><span class="p">);</span>

<span class="n">module_call_init</span><span class="p">(</span><span class="n">MODULE_INIT_QOM</span><span class="p">);</span>

<span class="n">module_call_init</span><span class="p">(</span><span class="n">MODULE_INIT_OPTS</span><span class="p">);</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>以这个QOM初始化为例，module_call_init()遍历QOM队列中的每个节点，并执行节点中的func函数。
而每个Type注册函数调用type_register_static()来完成TypeInfo到TypeImpl的转换：
 <img src="/pictures/qemu-module-04.svg" alt="函数调用流" /></p>

<p>而已经有了TypeInfo，为什么还要用TypeImpl，可能是为了速度(各个TypeInfo单独存在，
而TypeImpl是采用的Hash组织起来的)：
<img src="/pictures/qemu-module-05.svg" alt="数据结构" /></p>

<h3 id="typeimpl的操作">TypeImpl的操作</h3>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></td><td class="code"><pre><span class="n">qom</span><span class="o">/</span><span class="n">object</span><span class="p">.</span><span class="n">c</span>

<span class="k">static</span> <span class="n">GHashTable</span> <span class="o">*</span><span class="n">type_table_get</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">GHashTable</span> <span class="o">*</span><span class="n">type_table</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">type_table</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">type_table</span> <span class="o">=</span> <span class="n">g_hash_table_new</span><span class="p">(</span><span class="n">g_str_hash</span><span class="p">,</span> <span class="n">g_str_equal</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">type_table</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">enumerating_types</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">type_table_add</span><span class="p">(</span><span class="n">TypeImpl</span> <span class="o">*</span><span class="n">ti</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">enumerating_types</span><span class="p">);</span>
    <span class="n">g_hash_table_insert</span><span class="p">(</span><span class="n">type_table_get</span><span class="p">(),</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ti</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">TypeImpl</span> <span class="o">*</span><span class="nf">type_table_lookup</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">g_hash_table_lookup</span><span class="p">(</span><span class="n">type_table_get</span><span class="p">(),</span> <span class="n">name</span><span class="p">);</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>即TypeImpl采用的关键字为对象名字与对象之间建立Hash关系。</p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
